<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <title>è´ªåƒè›‡</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #faf8ef;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        "PingFang SC", "Microsoft YaHei", sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    * {
      box-sizing: border-box;
    }
    .wrapper {
      text-align: center;
      padding: 8px;
    }
    .top {
      margin-bottom: 10px;
    }
    .top h1 {
      margin: 0;
      font-size: 28px;
      color: #776e65;
      letter-spacing: 3px;
    }
    .score-row {
      margin-top: 4px;
      font-size: 14px;
      color: #776e65;
    }
    .score-row span {
      font-weight: 700;
      margin: 0 2px;
    }

    :root {
      --tile-size: min(32px, 4vw);
    }

    .grid {
      background: #bbada0;
      padding: calc(var(--tile-size) * 0.3);
      border-radius: 6px;
      display: inline-grid;
      grid-template-columns: repeat(20, var(--tile-size));
      grid-template-rows: repeat(20, var(--tile-size));
      gap: calc(var(--tile-size) * 0.18);
      box-shadow: 0 8px 20px rgba(187, 173, 160, 0.8);
      transition: transform 0.18s ease;
      touch-action: none;
    }

    .cell {
      width: var(--tile-size);
      height: var(--tile-size);
      border-radius: 4px;
      background: #cdc1b4;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: calc(var(--tile-size) * 0.6);
      font-weight: 700;
      color: #f9f6f2;
      transition: background 0.1s ease, transform 0.1s ease, box-shadow 0.1s ease;
      box-shadow: 0 2px 3px rgba(119, 110, 101, 0.35);
    }
    .cell.empty {
      background: #cdc1b4;
      color: transparent;
      box-shadow: none;
    }
    .cell.food {
      background: #f65e3b;
      box-shadow: 0 3px 6px rgba(246, 94, 59, 0.7);
      animation: food-pop 0.24s ease-out;
    }
    .cell.food::before {
      content: "ğŸ";
    }
    .cell.snake-body {
      background: #8f7a66;
      box-shadow: 0 3px 6px rgba(143, 122, 102, 0.7);
    }
    .cell.snake-head {
      background: #f2b179;
      box-shadow: 0 0 0 3px rgba(249, 246, 242, 0.5),
                  0 3px 6px rgba(242, 177, 121, 0.8);
      position: relative;
    }
    .cell.snake-head::before,
    .cell.snake-head::after {
      content: "";
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 999px;
      background: #776e65;
      top: 28%;
    }
    .cell.snake-head::before {
      left: 28%;
    }
    .cell.snake-head::after {
      right: 28%;
    }

    @keyframes food-pop {
      0% { transform: scale(0); }
      60% { transform: scale(1.15); }
      100% { transform: scale(1); }
    }

    .grid.shake {
      animation: grid-shake 0.22s ease-out;
    }
    @keyframes grid-shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      50% { transform: translateX(4px); }
      75% { transform: translateX(-3px); }
    }

    .status {
      margin-top: 8px;
      font-size: 13px;
      min-height: 18px;
      color: #776e65;
    }
    .tip {
      margin-top: 4px;
      font-size: 12px;
      color: #999;
    }

    @media (max-width: 480px) {
      :root {
        --tile-size: min(24px, 4.2vw);
      }
      .top h1 {
        font-size: 24px;
      }
      .score-row {
        font-size: 13px;
      }
      .tip {
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
<div class="wrapper">
  <div class="top">
    <h1>è´ªåƒè›‡</h1>
    <div class="score-row">
      åˆ†æ•°ï¼š<span id="score">0</span>
      Â· é•¿åº¦ï¼š<span id="length">0</span>
      Â· æœ€é«˜ï¼š<span id="best">0</span>
      Â· é€Ÿåº¦ï¼š<span id="speed-text">æ‚ é—²</span>
    </div>
  </div>

  <div id="grid" class="grid"></div>

  <div id="status" class="status"></div>
  <div class="tip">
    æŒ‰ä»»æ„é”®å¼€å§‹ / ç©ºæ ¼æš‚åœ | æ–¹å‘é”® / WASD æ§åˆ¶ | æ‰‹æœºæ»‘åŠ¨æ§åˆ¶æ–¹å‘
  </div>
</div>

<script>
  // ====== åŸºç¡€é…ç½® ======
  const ROWS = 20;
  const COLS = 20;
  const INIT_LEN = 4;      // åˆå§‹é•¿åº¦
  const COMBO_WINDOW = 4000; // 4 ç§’å†…è¿ç»­åƒç®—è¿åƒ
  const BEST_KEY = "snake_best_v1";

  const gridEl = document.getElementById("grid");
  const scoreEl = document.getElementById("score");
  const lengthEl = document.getElementById("length");
  const bestEl = document.getElementById("best");
  const speedTextEl = document.getElementById("speed-text");
  const statusEl = document.getElementById("status");

  // æ¸¸æˆçŠ¶æ€
  let snake = [];
  let direction = { x: 1, y: 0 }; // å½“å‰ç§»åŠ¨æ–¹å‘ï¼ˆå³ï¼‰
  let nextDir = null;             // å¸§é—´å¾…æ›´æ–°æ–¹å‘
  let food = null;
  let score = 0;
  let bestScore = 0;
  let gameState = "ready";        // "ready" | "running" | "paused" | "over"
  let tickTimer = null;

  // è¿åƒ / æç¤º
  let combo = 0;
  let bestCombo = 0;
  let lastEatTime = 0;
  let baseStatusText = "";
  let statusTimeoutId = null;

  // è§¦æ‘¸
  let touchStartX = 0;
  let touchStartY = 0;

  // ====== éŸ³æ•ˆ ======
  let audioCtx;
  function playBeep(freq = 440, duration = 0.08, type = "square", volume = 0.08, delay = 0) {
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!audioCtx) audioCtx = new AC();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      osc.connect(gain);
      gain.connect(audioCtx.destination);

      const startTime = audioCtx.currentTime + delay;
      gain.gain.setValueAtTime(volume, startTime);
      gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

      osc.start(startTime);
      osc.stop(startTime + duration);
    } catch (e) {
      console.error("éŸ³æ•ˆæ’­æ”¾å¤±è´¥", e);
    }
  }

  function moveSound() {
    playBeep(260, 0.04, "square", 0.04);
  }
  function eatSound() {
    playBeep(520, 0.07, "triangle", 0.08);
    playBeep(760, 0.07, "triangle", 0.08, 0.05);
  }
  function gameOverSound() {
    playBeep(240, 0.16, "sawtooth", 0.1);
    playBeep(160, 0.22, "sine", 0.12, 0.08);
  }

  // ====== å·¥å…·å‡½æ•° ======
  function coordKey(r, c) {
    return r + "," + c;
  }

  function randomEmptyCell() {
    const occupied = new Set(snake.map(seg => coordKey(seg.r, seg.c)));
    const empties = [];
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const key = coordKey(r, c);
        if (!occupied.has(key)) {
          empties.push({ r, c });
        }
      }
    }
    if (!empties.length) return null;
    const idx = Math.floor(Math.random() * empties.length);
    return empties[idx];
  }

  function loadBestScore() {
    try {
      const raw = localStorage.getItem(BEST_KEY);
      if (raw) {
        const v = parseInt(raw, 10);
        if (!Number.isNaN(v)) bestScore = v;
      }
    } catch (e) {
      bestScore = 0;
    }
    bestEl.textContent = bestScore;
  }

  function saveBestScore() {
    try {
      localStorage.setItem(BEST_KEY, String(bestScore));
    } catch (e) {
      console.warn("ä¿å­˜æœ€é«˜åˆ†å¤±è´¥", e);
    }
  }

  function setBaseStatus(text, color = "#776e65") {
    baseStatusText = text;
    if (!statusTimeoutId) {
      statusEl.textContent = text;
      statusEl.style.color = color;
    } else {
      // ç›®å‰æœ‰é«˜ä¼˜å…ˆçº§æç¤ºåœ¨æ˜¾ç¤ºï¼Œç­‰å®ƒç»“æŸåä¼šæ¢å¤ base æ–‡æœ¬
    }
  }

  function flashStatus(text, color = "#f97316", duration = 900) {
    if (statusTimeoutId) clearTimeout(statusTimeoutId);
    statusTimeoutId = null;
    statusEl.textContent = text;
    statusEl.style.color = color;
    statusTimeoutId = setTimeout(() => {
      statusTimeoutId = null;
      statusEl.textContent = baseStatusText;
      statusEl.style.color = "#776e65";
    }, duration);
  }

  function updateStats() {
    scoreEl.textContent = score;
    lengthEl.textContent = snake.length;
    bestEl.textContent = bestScore;
    speedTextEl.textContent = getSpeedLabel();
  }

  function getSpeedLabel() {
    const len = snake.length;
    if (len <= 6) return "æ‚ é—²";
    if (len <= 12) return "æ™®é€š";
    if (len <= 18) return "åå¿«";
    return "ç–¯ç‹‚";
  }

  // é€Ÿåº¦éšé•¿åº¦å˜å¿«
  function getIntervalByLength() {
    const len = snake.length;
    const extra = Math.max(0, len - INIT_LEN);
    const base = 200;      // åˆå§‹é—´éš”ï¼ˆæ¯«ç§’ï¼‰
    const per = 3;         // æ¯é•¿ä¸€èŠ‚å‡å°‘çš„é—´éš”
    const min = 80;        // æœ€å¿«
    let interval = base - extra * per;
    if (interval < min) interval = min;
    return interval;
  }

  // ====== æ£‹ç›˜æ„å»º & æ¸²æŸ“ ======
  function buildGrid() {
    gridEl.innerHTML = "";
    gridEl.style.gridTemplateColumns = `repeat(${COLS}, var(--tile-size))`;
    gridEl.style.gridTemplateRows = `repeat(${ROWS}, var(--tile-size))`;

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const cell = document.createElement("div");
        cell.className = "cell empty";
        cell.dataset.row = r;
        cell.dataset.col = c;
        gridEl.appendChild(cell);
      }
    }
  }

  function renderScene() {
    const cells = gridEl.children;
    const snakeMap = new Map();
    snake.forEach((seg, idx) => {
      snakeMap.set(coordKey(seg.r, seg.c), idx);
    });

    for (let i = 0; i < cells.length; i++) {
      const cell = cells[i];
      const r = parseInt(cell.dataset.row, 10);
      const c = parseInt(cell.dataset.col, 10);
      const key = coordKey(r, c);

      cell.className = "cell empty";
      cell.textContent = "";

      // é£Ÿç‰©
      if (food && food.r === r && food.c === c) {
        cell.className = "cell food";
        continue;
      }

      // è›‡
      if (snakeMap.has(key)) {
        const idxInSnake = snakeMap.get(key);
        if (idxInSnake === 0) {
          cell.className = "cell snake-head";
        } else {
          cell.className = "cell snake-body";
        }
      }
    }
  }

  // ====== æ¸¸æˆæµç¨‹ ======
  function resetGame() {
    const midR = Math.floor(ROWS / 2);
    const midC = Math.floor(COLS / 2) - 1;

    snake = [
      { r: midR, c: midC + 1 }, // å¤´
      { r: midR, c: midC },
      { r: midR, c: midC - 1 },
      { r: midR, c: midC - 2 }
    ];
    direction = { x: 1, y: 0 };
    nextDir = null;
    food = randomEmptyCell();
    score = 0;
    combo = 0;
    bestCombo = 0;
    lastEatTime = 0;

    if (tickTimer) {
      clearInterval(tickTimer);
      tickTimer = null;
    }
    gameState = "ready";
    gridEl.classList.remove("shake");

    setBaseStatus("æŒ‰ä»»æ„é”®å¼€å§‹ï¼Œæ–¹å‘é”® / WASD æ§åˆ¶æ–¹å‘");
    updateStats();
    renderScene();
  }

  function startLoop() {
    if (tickTimer) {
      clearInterval(tickTimer);
      tickTimer = null;
    }
    const interval = getIntervalByLength();
    tickTimer = setInterval(gameTick, interval);
  }

  function startGame() {
    if (gameState === "running") return;
    gameState = "running";
    setBaseStatus("å°å¿ƒåˆ«æ’åˆ°å¢™å’Œè‡ªå·±çš„èº«ä½“ï½");
    startLoop();
  }

  function togglePause() {
    if (gameState === "running") {
      gameState = "paused";
      if (tickTimer) {
        clearInterval(tickTimer);
        tickTimer = null;
      }
      setBaseStatus("å·²æš‚åœï¼ŒæŒ‰ç©ºæ ¼ç»§ç»­");
    } else if (gameState === "paused") {
      gameState = "running";
      setBaseStatus("å°å¿ƒåˆ«æ’åˆ°å¢™å’Œè‡ªå·±çš„èº«ä½“ï½");
      startLoop();
    }
  }

  function onGameOver() {
    gameState = "over";
    if (tickTimer) {
      clearInterval(tickTimer);
      tickTimer = null;
    }
    gridEl.classList.add("shake");
    setBaseStatus(
      "æ¸¸æˆç»“æŸï¼Œæœ¬å±€æœ€å¤§è¿åƒ x" + bestCombo + "ï¼ŒæŒ‰ä»»æ„é”®å†æ¥ä¸€å±€",
      "#ef4444"
    );
    gameOverSound();
    setTimeout(() => {
      gridEl.classList.remove("shake");
    }, 260);
  }

  function applyDirection(dx, dy) {
    // ä¸å…è®¸ç›´æ¥åå‘
    const opposite =
      (direction.x === 1 && dx === -1) ||
      (direction.x === -1 && dx === 1) ||
      (direction.y === 1 && dy === -1) ||
      (direction.y === -1 && dy === 1);
    if (opposite && snake.length > 1) return;
    nextDir = { x: dx, y: dy };
  }

  function gameTick() {
    if (gameState !== "running") return;

    if (nextDir) {
      direction = nextDir;
      nextDir = null;
    }

    const head = snake[0];
    const newR = head.r + direction.y;
    const newC = head.c + direction.x;

    // æ’å¢™
    if (newR < 0 || newR >= ROWS || newC < 0 || newC >= COLS) {
      onGameOver();
      return;
    }

    // æ’è‡ªå·±
    for (let i = 0; i < snake.length; i++) {
      if (snake[i].r === newR && snake[i].c === newC) {
        onGameOver();
        return;
      }
    }

    // ç§»åŠ¨
    snake.unshift({ r: newR, c: newC });

    // åƒåˆ°é£Ÿç‰©
    if (food && newR === food.r && newC === food.c) {
      eatSound();
      const now = Date.now();
      if (lastEatTime && now - lastEatTime <= COMBO_WINDOW) {
        combo++;
      } else {
        combo = 1;
      }
      lastEatTime = now;
      if (combo > bestCombo) bestCombo = combo;

      const baseGain = 10;
      const comboBonus = (combo - 1) * 5;
      const gain = baseGain + comboBonus;
      score += gain;

      // æœ€é«˜åˆ†
      if (score > bestScore) {
        bestScore = score;
        saveBestScore();
        flashStatus("æ–°çºªå½•ï¼å½“å‰åˆ†æ•° " + score, "#22c55e", 1200);
      } else if (combo >= 2) {
        flashStatus(
          "è¿åƒ x" + combo + "  +" + gain + " åˆ†",
          "#f97316",
          900
        );
      }

      food = randomEmptyCell();
      updateStats();
      renderScene();
      // é•¿åº¦å˜é•¿ â†’ é‡æ–°æ ¹æ®é•¿åº¦è°ƒæ•´é€Ÿåº¦
      startLoop();
    } else {
      // æ²¡åƒåˆ°ï¼Œæ­£å¸¸å‰è¿›
      snake.pop();
      moveSound();
      renderScene();
    }
  }

  // ====== é”®ç›˜ & è§¦æ‘¸æ§åˆ¶ ======
  function handleKeydown(e) {
    const key = e.key;

    let startedThisKey = false;

    // ä»»æ„é”®å¼€å§‹ / ç»“æŸåä»»æ„é”®é‡å¼€
    if (gameState === "ready") {
      startGame();
      startedThisKey = true;
    } else if (gameState === "over") {
      resetGame();
      startGame();
      startedThisKey = true;
    }

    // ç©ºæ ¼ï¼šæš‚åœ/ç»§ç»­
    if (key === " " || key === "Spacebar") {
      // é¿å…ç¬¬ä¸€ä¸‹ç©ºæ ¼åˆšå¼€å§‹å°±ç«‹å³æš‚åœ
      if (!startedThisKey) {
        togglePause();
      }
      return;
    }

    // æ–¹å‘é”® / WASD
    if (key === "ArrowUp" || key === "w" || key === "W") {
      applyDirection(0, -1);
    } else if (key === "ArrowDown" || key === "s" || key === "S") {
      applyDirection(0, 1);
    } else if (key === "ArrowLeft" || key === "a" || key === "A") {
      applyDirection(-1, 0);
    } else if (key === "ArrowRight" || key === "d" || key === "D") {
      applyDirection(1, 0);
    }
  }

  // æ‰‹æœºæ»‘åŠ¨ï¼šåŒæ ·æ”¯æŒâ€œç¬¬ä¸€æ¬¡æ»‘åŠ¨å°±å¼€å§‹æ¸¸æˆâ€
  gridEl.addEventListener(
    "touchstart",
    e => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;

      if (gameState === "ready") {
        startGame();
      } else if (gameState === "over") {
        resetGame();
        startGame();
      }
    },
    { passive: true }
  );

  gridEl.addEventListener("touchend", e => {
    if (e.changedTouches.length !== 1) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    const absX = Math.abs(dx);
    const absY = Math.abs(dy);
    const threshold = 20;
    if (absX < threshold && absY < threshold) return;

    if (absX > absY) {
      // æ°´å¹³
      if (dx > 0) applyDirection(1, 0);
      else applyDirection(-1, 0);
    } else {
      // å‚ç›´
      if (dy > 0) applyDirection(0, 1);
      else applyDirection(0, -1);
    }
  });

  // ====== åˆå§‹åŒ– ======
  window.addEventListener("keydown", handleKeydown);

  buildGrid();
  loadBestScore();
  resetGame();
</script>
</body>
</html>
