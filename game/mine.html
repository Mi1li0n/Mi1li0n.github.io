<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
  <title>åœ°åº•çŸ¿å·¥ Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    :root {
      --bg: #020617;
      --panel-bg: #0f172a;
      --accent: #fbbf24;
      --danger: #f97373;
      --good: #4ade80;
      --grid-border: #1f2937;
      --rock: #111827;
      --floor: #020617;
      --ore: #1d4ed8;
      --hole: #111827;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: radial-gradient(circle at top, #020617, #000);
      font-family: -apple-system, BlinkMacSystemFont,"Segoe UI",Roboto,
        "PingFang SC","Microsoft YaHei",sans-serif;
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    body {
      padding: 8px;
    }
    .hidden { display: none !important; }

    #game-root {
      width: 100%;
      max-width: 1100px;
      height: 720px;
      max-height: 100vh;
      background: linear-gradient(145deg,#020617,#020617 60%,#020617);
      border-radius: 18px;
      box-shadow: 0 24px 60px rgba(15,23,42,0.9);
      display: grid;
      grid-template-columns: 3fr 1.2fr;
      overflow: hidden;
      border: 1px solid #1f2937;
    }

    /* å¼€åœºæ•…äº‹ */
    #start-screen {
      width: 100%;
      max-width: 900px;
      height: 560px;
      max-height: 100vh;
      background: radial-gradient(circle at top,#0f172a,#000);
      border-radius: 18px;
      box-shadow: 0 24px 60px rgba(15,23,42,0.9);
      padding: 20px 24px;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
      border: 1px solid #1f2937;
    }
    .story-illu {
      flex: 1;
      border-radius: 16px;
      background: radial-gradient(circle at top,#1e293b,#020617);
      border: 1px solid #1f2937;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .story-illu::before {
      content:"";
      position:absolute;
      inset:-20%;
      background:
        radial-gradient(circle at top left,rgba(251,191,36,0.18),transparent 60%),
        radial-gradient(circle at bottom right,rgba(59,130,246,0.22),transparent 55%);
      mix-blend-mode: screen;
      opacity:0.9;
    }
    .story-miner {
      position: relative;
      width: 180px;
      height: 220px;
      border-radius: 24px;
      background: radial-gradient(circle at top,#facc15,#f97316);
      box-shadow: 0 18px 40px rgba(234,179,8,0.6);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      color:#111827;
      font-weight:700;
    }
    .story-miner span.big {
      font-size: 60px;
      filter: drop-shadow(0 6px 10px rgba(15,23,42,0.6));
    }
    .story-miner span.text {
      margin-top:4px;
      font-size: 13px;
      letter-spacing: 2px;
    }
    .story-torch {
      position:absolute;
      right:40px;
      bottom:40px;
      width:70px;
      height:120px;
      border-radius:18px;
      background: radial-gradient(circle at top,#fed7aa,#9a3412 70%,#000);
      box-shadow: 0 20px 40px rgba(248,113,113,0.6);
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding-bottom:10px;
      font-size:32px;
    }
    .story-text {
      margin-top: 12px;
      min-height: 110px;
      font-size: 14px;
      line-height: 1.7;
      color:#e5e7eb;
      white-space: pre-line;
    }
    .story-step {
      font-size: 12px;
      color:#9ca3af;
    }
    .story-controls {
      margin-top: 8px;
      display:flex;
      justify-content: space-between;
      align-items:center;
    }
    .btn {
      border-radius:999px;
      border:1px solid rgba(148,163,184,0.8);
      background: radial-gradient(circle at top,#1f2937,#020617);
      color:#e5e7eb;
      padding:6px 14px;
      font-size: 13px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:4px;
      box-shadow: 0 6px 18px rgba(15,23,42,0.9);
      transition:transform 0.1s ease,box-shadow 0.1s ease,background 0.1s ease;
    }
    .btn-primary {
      border-color: #fbbf24;
      background: linear-gradient(120deg,#facc15,#f97316);
      color:#111827;
      box-shadow: 0 8px 20px rgba(251,191,36,0.6);
    }
    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 26px rgba(15,23,42,0.9);
    }
    .btn:active {
      transform: translateY(1px);
      box-shadow: 0 3px 10px rgba(15,23,42,0.8);
    }

    /* å·¦ä¾§ä¸»è§†å›¾ */
    .main-view {
      background: radial-gradient(circle at top,#020617,#020617 60%,#000);
      padding: 10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .top-hud {
      display:flex;
      justify-content: space-between;
      align-items:center;
      padding: 4px 6px;
      border-radius:12px;
      background: rgba(15,23,42,0.85);
      border:1px solid #111827;
      box-shadow: inset 0 0 0 1px rgba(148,163,184,0.12);
      font-size: 14px;
    }
    .hud-left, .hud-right {
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .hud-pill {
      padding:4px 9px;
      border-radius:999px;
      background: rgba(15,23,42,0.85);
      border:1px solid rgba(148,163,184,0.6);
      display:flex;
      align-items:center;
      gap:6px;
    }
    .hud-label {
      color:#9ca3af;
      font-size:12px;
    }
    .hearts, .armor {
      display:flex;
      gap:2px;
      font-size:16px;
    }

    .view-container {
      flex:1;
      border-radius: 16px;
      background: radial-gradient(circle at top,#020617,#000);
      border:1px solid #111827;
      box-shadow: 0 16px 40px rgba(15,23,42,0.9);
      padding:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
    }

    .grid {
      display:grid;
      background:#020617;
      border-radius: 10px;
      padding:4px;
      border:1px solid #1f2937;
    }
    .base-grid {
      grid-template-columns: repeat(3, 42px);
      grid-template-rows: repeat(3, 42px);
      gap:3px;
    }
    .dungeon-grid {
      grid-template-columns: repeat(28, 18px);
      grid-template-rows: repeat(28, 18px);
      gap:2px;
    }
    .tile {
      width:100%;
      height:100%;
      border-radius:5px;
      font-size:16px;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select:none;
      position: relative; /* â˜… å…³é”®ï¼šè®© ::after ä»¥æ ¼å­ä¸ºå®šä½å‚ç…§ */
      transition: background 0.08s ease, box-shadow 0.08s ease, transform 0.08s ease, filter 0.08s ease;
    }
    .tile.base {
      background:#020617;
      border:1px solid #1f2937;
    }
    .tile.base.bed { background:#172554; }
    .tile.base.chest { background:#78350f; }
    .tile.base.stairs { background:#064e3b; }
    .tile.base.merchant { background:#4b5563; }
    .tile.base.player { box-shadow:0 0 0 2px #facc15;}

    .tile.dungeon { background: #020617; border:1px solid #020617; font-size:12px;}
    .tile.spawn {
      box-shadow:0 0 0 2px rgba(251,191,36,0.9);
    }
    .tile.rock { background: var(--rock); }
    .tile.floor { background: var(--floor); border-color:#1f2937;}
    .tile.ore { background: radial-gradient(circle at top,#1d4ed8,#020617); border-color:#1d4ed8; }
    .tile.hole {
      background: var(--floor);
      border-color:#1f2937;
    }
    .tile.stair-up { background:#065f46;}
    .tile.chest { background:#78350f;}
    .tile.monster { box-shadow:0 0 0 1px rgba(248,113,113,0.8);}

    .tile.monster.monster-moving {
      animation: monster-move-pulse 1s ease-out;
    }
    @keyframes monster-move-pulse {
      0%   { transform: scale(0.8); opacity: 0.4; }
      50%  { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1.0); opacity: 1; }
    }

    .tile.player {
      box-shadow:0 0 0 2px #facc15;
      position:relative;
    }
    .tile.ghost-tele::after {
      content:"";
      position:absolute;
      inset:2px;
      border-radius:4px;
      background: rgba(248, 113, 113, 0.25);
      box-shadow:0 0 10px rgba(248,113,113,0.9);
      pointer-events:none;
    }
    /* ç²˜æ¶²æ€ªå¼¹è·³è½ç‚¹ */
    .tile.slime-tele::after {
      content:"";
      position:absolute;
      inset:2px;
      border-radius:4px;
      background: rgba(59, 130, 246, 0.25);    /* åŠé€æ˜è“åº• */
      box-shadow:0 0 10px rgba(59,130,246,0.9);
      pointer-events:none;
    }

    /* å¹½çµ/ç²˜æ¶²æ€ªè‡ªèº«å˜è‰²é¢„è­¦ */
    .tile.monster.mon-ghost-charging::before,
    .tile.monster.mon-slime-charging::before {
      content:"";
      position:absolute;
      inset:4px;
      border-radius:6px;
      box-shadow:0 0 12px rgba(248,113,113,0.0);
      pointer-events:none;
    }

    .tile.monster.mon-ghost-charging {
      box-shadow:0 0 0 2px rgba(248,113,113,0.9);
    }

    .tile.monster.mon-slime-charging {
      box-shadow:0 0 0 2px rgba(59,130,246,0.9);
    }
    .tile.bomb {
      box-shadow:0 0 0 2px rgba(248,113,113,0.8);
    }

    .tile.fog {
      background:#000;
      border-color:#000;
    }
    .tile.dim {
      filter: brightness(0.55) grayscale(0.6);
    }

    .log-panel {
      position:absolute;
      left:8px;
      bottom:8px;
      right:8px;
      pointer-events:none;
      font-size:14px;
      color:#9ca3af;
      background: linear-gradient(to top,rgba(15,23,42,0.9),rgba(15,23,42,0));
      padding:2px 4px 4px;
      border-radius:10px;
    }
    .log-line { opacity:0.9; }
    .log-line.important { color:#facc15;}

    /* å³ä¾§ä¿¡æ¯æ  */
    .side-panel {
      background: var(--panel-bg);
      border-left:1px solid #111827;
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      font-size: 14px; /* æ–°å¢ï¼Œè®©ä¾§æ æ€»ä½“å¤§ä¸€ç‚¹ */
    }
    .side-section {
      background: rgba(15,23,42,0.8);
      border-radius:12px;
      border:1px solid #111827;
      padding:8px;
      font-size:13px;
    }
    .side-title {
      font-size:13px;
      color:#9ca3af;
      margin-bottom:4px;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .stat-row {
      display:flex;
      justify-content:space-between;
      margin-bottom:2px;
    }
    .controls-list span.key {
      display:inline-block;
      border-radius:6px;
      border:1px solid #4b5563;
      padding:1px 4px;
      margin-right:4px;
      font-size:11px;
      background:#020617;
    }

    /* èƒŒåŒ… / ç®±å­æ ¼å­ */
    .inv-grid {
      display:grid;
      gap:3px;
    }
    .inv-backpack {
      grid-template-columns: repeat(2, 26px);
    }
    .inv-chest {
      grid-template-columns: repeat(5, 26px);
    }
    .inv-slot {
      width:26px;
      height:26px;
      border-radius:5px;
      background:#020617;
      border:1px solid #4b5563;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:16px;
      position:relative;
      cursor:pointer;
    }
    .inv-slot-empty {
      opacity:0.4;
      font-size:12px;
    }
    .inv-count {
      position:absolute;
      right:2px;
      bottom:0;
      font-size:10px;
      color:#e5e7eb;
      text-shadow:0 0 4px #000;
    }

    /* æ¨¡æ€æ¡† */
    .modal {
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:40;
    }
    .modal.hidden { display:none; }
    .modal-backdrop {
      position:absolute;
      inset:0;
      background:rgba(15,23,42,0.8);
    }
    .modal-content {
      position:relative;
      z-index:41;
      background:#020617;
      border-radius:14px;
      border:1px solid #4b5563;
      padding:10px 11px;
      width:340px;
      max-width:92vw;
      box-shadow:0 18px 50px rgba(0,0,0,0.9);
      font-size:13px;
    }
    .modal-title {
      margin:0 0 6px;
      font-size:14px;
      color:#e5e7eb;
    }
    .modal-body { margin-bottom:6px; }
    .shop-item {
      display:flex;
      justify-content: space-between;
      align-items:center;
      margin-bottom:4px;
    }
    .shop-name { font-weight:500; }
    .shop-desc {
      font-size:11px;
      color:#9ca3af;
    }
    .tag {
      display:inline-block;
      border-radius:999px;
      border:1px solid #4b5563;
      padding:1px 6px;
      font-size:10px;
      color:#9ca3af;
    }
    .text-danger { color:var(--danger);}
    .text-good { color:var(--good);}

    @media (max-width:960px) {
      #game-root {
        grid-template-columns: 1.7fr 1.3fr;
      }
      .dungeon-grid {
        grid-template-columns: repeat(28, 18px);
        grid-template-rows: repeat(28, 18px);
        gap:2px;
      }
    }
    @media (max-width:720px) {
      #game-root {
        grid-template-columns: 1fr;
        grid-template-rows: 1.5fr auto;
        height:auto;
      }
      .side-panel {
        border-left:none;
        border-top:1px solid #111827;
        flex-direction:row;
        flex-wrap:wrap;
      }
      .side-section {
        flex:1 1 45%;
      }
    }
  </style>
</head>
<body>

<div id="start-screen">
  <div class="story-illu">
    <div class="story-miner">
      <span class="big">â›ï¸</span>
      <span class="text">æ˜åœ°æ±‚ç”Ÿ</span>
    </div>
    <div class="story-torch">ğŸ”¥</div>
  </div>
  <div class="story-text" id="story-text"></div>
  <div class="story-controls">
    <div class="story-step" id="story-step"></div>
    <div>
      <button class="btn" id="btn-skip">è·³è¿‡</button>
      <button class="btn btn-primary" id="btn-next">ä¸‹ä¸€æ®µ</button>
    </div>
  </div>
</div>

<div id="game-root" class="hidden">
  <div class="main-view">
    <div class="top-hud">
      <div class="hud-left">
        <div class="hud-pill">
          <span class="hud-label">å¤©æ•°</span>
          <span id="hud-day">1</span>
        </div>
        <div class="hud-pill">
          <span class="hud-label">å›åˆ</span>
          <span id="hud-turns">-</span>
        </div>
        <div class="hud-pill">
          <span class="hud-label">çŸ¿çŸ³</span>
          <span id="hud-ore">0</span>
        </div>
      </div>
      <div class="hud-right">
        <div class="hud-pill">
          <span class="hud-label">ç”Ÿå‘½</span>
          <div class="hearts" id="hud-hearts"></div>
        </div>
        <div class="hud-pill">
          <span class="hud-label">æŠ¤ç”²</span>
          <div class="armor" id="hud-armor"></div>
        </div>
        <div class="hud-pill">
          <span class="hud-label">ç¨¿å­</span>
          <span id="hud-pickaxe"></span>
        </div>
      </div>
    </div>

    <div class="view-container">
      <div id="base-view" class="grid base-grid"></div>
      <div id="dungeon-view" class="grid dungeon-grid hidden"></div>

      <div class="log-panel" id="log-panel"></div>
    </div>
  </div>

  <div class="side-panel">
    <div class="side-section">
      <div class="side-title">
        <span>è§’è‰²çŠ¶æ€</span>
        <span class="tag" id="tag-location">åŸºåœ°</span>
      </div>
      <div class="stat-row">
        <span>å½“å‰åœ°ç‚¹</span><span id="stat-loc-text">ä¸´æ—¶åŸºåœ°</span>
      </div>
      <div class="stat-row">
        <span>ä¸´æ—¶ç”Ÿå‘½</span><span id="stat-temp-hp">0</span>
      </div>
      <div class="stat-row">
        <span>çœ©æ™•å›åˆ</span><span id="stat-stun">0</span>
      </div>
      <div class="stat-row">
        <span>æ€ªç‰©æ•°é‡</span><span id="stat-monsters">0</span>
      </div>
      <div class="stat-row">
        <span>æŠ¤ç¬¦æ•°é‡</span><span id="stat-charm">0</span>
      </div>
      <div class="stat-row">
        <span>å°–åˆºç›¾ç‰Œ</span><span id="stat-shield">0</span>
      </div>
    </div>

    <div class="side-section">
      <div class="side-title">
        <span>èƒŒåŒ… 2Ã—2</span>
      </div>
      <div class="inv-grid inv-backpack" id="backpack-grid"></div>
      <div style="margin-top:6px;font-size:11px;color:#9ca3af;">
        é¢åŒ…ï¼š<span id="stat-bread">0</span>ï¼Œ
        ç«æŠŠï¼š<span id="stat-torch">0</span>ï¼Œ
        ç‚¸è¯åŒ…ï¼š<span id="stat-bomb">0</span>ï¼Œ
        ç»³ç´¢ï¼š<span id="stat-rope">0</span>
      </div>
    </div>

    <div class="side-section">
      <div class="side-title">
        <span>æ“ä½œè¯´æ˜</span>
      </div>
      <div class="controls-list">
        <div><span class="key">WASD</span><span class="key">â†‘â†“â†â†’</span>ç§»åŠ¨</div>
        <div><span class="key">E</span><span class="key">ç©ºæ ¼</span>äº¤äº’ / ä¸Šä¸‹æ¥¼</div>
        <div><span class="key">B</span>åƒé¢åŒ…ï¼ˆ+1 ç”Ÿå‘½æˆ–ä¸´æ—¶ç”Ÿå‘½ï¼‰</div>
        <div><span class="key">T</span>æ’ä¸‹ç«æŠŠï¼ˆçŸ¿æ´ï¼‰</div>
        <div><span class="key">F</span>æ”¾ç½®ç‚¸è¯åŒ…ï¼ˆçŸ¿æ´ï¼‰</div>
        <div><span class="key">R</span>ä½¿ç”¨ç»³ç´¢ï¼ˆè®¾ç½®/å›åˆ°é”šç‚¹ï¼‰</div>
        <div style="margin-top:4px;color:#9ca3af;">åœ°ä¸‹ï¼šèµ°è¿›å²©çŸ³ = æŒ–æ˜ï¼Œèµ°è¿›æ€ªç‰© = æ”»å‡»</div>
      </div>
    </div>
  </div>
</div>

<!-- å•†äºº -->
<div class="modal hidden" id="modal-merchant">
  <div class="modal-backdrop"></div>
  <div class="modal-content">
    <h3 class="modal-title">åœ°åº•æµæµªå•†äºº ğŸ§™â€â™‚ï¸</h3>
    <div class="modal-body">
      <div style="font-size:12px;margin-bottom:6px;">
        æ‰‹é‡Œæœ‰äº›ä»€ä¹ˆè¦æ¢ï¼Ÿä½ å½“å‰æœ‰
        <span class="text-good" id="shop-ore">0</span> å—çŸ¿çŸ³ã€‚
      </div>
      <div id="shop-list"></div>
    </div>
    <div style="display:flex;justify-content:flex-end;gap:6px;margin-top:4px;">
      <button class="btn" id="btn-shop-close">ç¦»å¼€</button>
    </div>
  </div>
</div>

<!-- ç®±å­ -->
<div class="modal hidden" id="modal-chest">
  <div class="modal-backdrop"></div>
  <div class="modal-content">
    <h3 class="modal-title">ä¸´æ—¶åŸºåœ°ç®±å­ ğŸ“¦</h3>
    <div class="modal-body">
      <div style="margin-bottom:4px;font-size:12px;color:#9ca3af;">
        ç‚¹å‡»èƒŒåŒ…æ ¼å­å¯å­˜å…¥ç®±å­ï¼Œç‚¹å‡»ç®±å­æ ¼å­å¯å–å›åˆ°èƒŒåŒ…ã€‚
      </div>
      <div style="display:flex;gap:8px;">
        <div style="flex:1;">
          <div class="side-title" style="margin-bottom:4px;">
            <span>ç®±å­ 5Ã—5</span>
          </div>
          <div class="inv-grid inv-chest" id="chest-grid"></div>
        </div>
        <div style="flex:0 0 80px;">
          <div class="side-title" style="margin-bottom:4px;">
            <span>èƒŒåŒ…</span>
          </div>
          <div class="inv-grid inv-backpack" id="bp-grid-modal"></div>
        </div>
      </div>
    </div>
    <div style="display:flex;justify-content:flex-end;gap:6px;margin-top:4px;">
      <button class="btn" id="btn-chest-close">å…³é—­</button>
    </div>
  </div>
</div>

<!-- Game Over -->
<div class="modal hidden" id="modal-gameover">
  <div class="modal-backdrop"></div>
  <div class="modal-content">
    <h3 class="modal-title">ä½ è¢«åŸ‹åœ¨é»‘æš—ä¹‹ä¸­â€¦â€¦</h3>
    <div class="modal-body">
      <p style="font-size:12px;line-height:1.6;">
        çŸ¿å·¥çš„æ•…äº‹æš‚æ—¶åœ¨è¿™é‡Œç”»ä¸Šå¥å·ã€‚<br/>
        ä½†æ´ç©´è¿˜åœ¨é‚£å„¿ï¼Œç­‰ä½ é‡æ–°ç‚¹äº®ç¬¬ä¸€æ”¯ç«æŠŠã€‚
      </p>
    </div>
    <div style="display:flex;justify-content:flex-end;gap:6px;margin-top:4px;">
      <button class="btn btn-primary" id="btn-restart-run">é‡æ–°å¼€å§‹</button>
    </div>
  </div>
</div>

<!-- Demo ç»“æŸ -->
<div class="modal hidden" id="modal-demoend">
  <div class="modal-backdrop"></div>
  <div class="modal-content">
    <h3 class="modal-title">å¥³å·«çš„ç»ˆç»“ä»ªå¼ âœ¨</h3>
    <div class="modal-body">
      <p style="font-size:12px;line-height:1.7;">
        ç¬¬åå¤©çš„å¤œé‡Œï¼Œå¥³å·«æŒ¥æ‰‹ï¼Œç®€é™‹çš„ä¸´æ—¶åŸºåœ°åœ¨å’’è¯­ä¸­å´©å¡Œã€‚<br/>
        ä½ ä¾¥å¹¸æ´»äº†ä¸‹æ¥ï¼Œå´åªèƒ½é‡æ–°å¼€å§‹è§„åˆ’ä¸€åˆ‡ã€‚<br/><br/>
        <span class="text-good">æ„Ÿè°¢æ¸¸ç© Demoï¼</span>
      </p>
    </div>
    <div style="display:flex;justify-content:flex-end;gap:6px;margin-top:4px;">
      <button class="btn btn-primary" id="btn-demo-restart">å†æ¥ä¸€è½®</button>
    </div>
  </div>
</div>

<script>
  // ============ æ•…äº‹å¼€åœº ============

  const storyTexts = [
    "è¿™æ˜¯ä¸€ä¸ªå‰‘ä¸é­”æ³•çš„æ—¶ä»£ï¼Œä¹Ÿæ˜¯çŸ¿çŸ³å’Œé»„é‡‘çš„æ—¶ä»£ã€‚\nä½ ï¼Œæ˜¯ä¸€åæ™®é€šåˆ°ä¸èƒ½å†æ™®é€šçš„çŸ¿å·¥ã€‚",
    "ä¸€æ¬¡æ™®é€šçš„æŒ–æ˜ä»»åŠ¡ä¸­ï¼Œåœ°åº•çš„å²©å£çªç„¶å¡Œé™·ã€‚\nå¡Œæ–¹ã€å°˜åœŸã€å°–å«ï¼Œæœ€ååªå‰©ä¸‹é»‘æš—å’Œè€³é¸£ã€‚",
    "å½“ä½ é†’æ¥æ—¶ï¼Œä½ è¢«å›°åœ¨ä¸€å¤„ä¸´æ—¶æ­å»ºçš„å°å‹åŸºåœ°é‡Œã€‚\nä¸Šæ–¹çš„é€šé“å·²ç»è¢«å®Œå…¨æ©åŸ‹ï¼Œå”¯ä¸€çš„å‡ºè·¯â€”â€”\nåªæœ‰ç»§ç»­å‘æ›´æ·±å¤„æŒ–æ˜ã€‚",
    "åœ¨æ´ç©´æ·±å¤„ï¼Œæ½œä¼ç€çŸ¿è„‰ã€å®ç‰©ï¼Œè¿˜æœ‰é¥¥é¥¿çš„æ€ªç‰©ã€‚\næ´»ä¸‹å»ï¼ŒæŒ–åˆ°è¶³å¤Ÿçš„èµ„æºï¼Œä¹Ÿè®¸è¿˜èƒ½ç­‰æ¥æ•‘æ´â€¦â€¦\næˆ–æ˜¯ï¼Œé‡åˆ°æ›´å¯æ€•çš„ä¸œè¥¿ã€‚"
  ];
  let storyIndex = 0;
  const storyTextEl = document.getElementById("story-text");
  const storyStepEl = document.getElementById("story-step");
  const startScreenEl = document.getElementById("start-screen");
  const gameRootEl = document.getElementById("game-root");

  function renderStory() {
    storyTextEl.innerText = storyTexts[storyIndex];
    storyStepEl.textContent = `æ®µè½ ${storyIndex+1} / ${storyTexts.length}`;
    const nextBtn = document.getElementById("btn-next");
    nextBtn.textContent = storyIndex === storyTexts.length-1 ? "å¼€å§‹æ¸¸æˆ" : "ä¸‹ä¸€æ®µ";
  }

  document.getElementById("btn-next").addEventListener("click", () => {
    if (storyIndex < storyTexts.length - 1) {
      storyIndex++;
      renderStory();
    } else {
      startScreenEl.classList.add("hidden");
      gameRootEl.classList.remove("hidden");
      startNewRun();
    }
  });
  document.getElementById("btn-skip").addEventListener("click", () => {
    startScreenEl.classList.add("hidden");
    gameRootEl.classList.remove("hidden");
    startNewRun();
  });

  renderStory();

  // ============ å·¥å…·å‡½æ•° ============

  function makeRng(seed) {
    let x = seed % 2147483647;
    if (x <= 0) x += 2147483646;
    return function() {
      x = x * 16807 % 2147483647;
      return (x - 1) / 2147483646;
    };
  }

  function randInt(rng, min, max) {
    return Math.floor(rng() * (max - min + 1)) + min;
  }

  function hasLineOfSight(sx, sy, tx, ty, ignoreRock = false) {
    const d = gameState.dungeon;
    if (!d) return false;
    if (sx === tx && sy === ty) return true;

    let x0 = sx, y0 = sy;
    let x1 = tx, y1 = ty;
    let dx = Math.abs(x1 - x0);
    let dy = Math.abs(y1 - y0);
    let sxStep = x0 < x1 ? 1 : -1;
    let syStep = y0 < y1 ? 1 : -1;
    let err = dx - dy;

    let x = x0, y = y0;
    while (!(x === x1 && y === y1)) {
      const e2 = 2 * err;
      if (e2 > -dy) { err -= dy; x += sxStep; }
      if (e2 < dx) { err += dx; y += syStep; }
      if (x === x1 && y === y1) break;

      if (!ignoreRock && d.tiles[y][x].type === TILE_ROCK) {
        return false;
      }
    }
    return true;
  }


  function clamp(v, min, max) {
    return v < min ? min : (v > max ? max : v);
  }

  function shuffle(rng, arr) {
    for (let i=arr.length-1;i>0;i--) {
      const j = Math.floor(rng()* (i+1));
      [arr[i],arr[j]] = [arr[j],arr[i]];
    }
  }

  // ============ å¸¸é‡ ============

  const TILE_ROCK = "rock";
  const TILE_FLOOR = "floor";
  const TILE_ORE = "ore";
  const TILE_HOLE = "hole";
  const TILE_STAIR_UP = "stair_up";
  const TILE_CHEST = "chest";
  const PLAYER_LIGHT_RADIUS = 4; // ç©å®¶åŸºç¡€å…‰ç…§åŠå¾„ï¼ˆè§†é‡åŠå¾„ï¼‰

  const MON_ZOMBIE = "zombie";
  const MON_SLIME = "slime";
  const MON_GHOST = "ghost";

  const GameMode = {
    BASE: "base",
    DUNGEON: "dungeon"
  };

  const INV_BACKPACK_W = 2;
  const INV_BACKPACK_H = 2;
  const INV_CHEST_W = 5;
  const INV_CHEST_H = 5;

  const ITEM_DEFS = {
    ore:   { icon:"ğŸ’", name:"çŸ¿çŸ³", maxStack:32 },
    bread: { icon:"ğŸ", name:"é¢åŒ…", maxStack:1 },
    torch: { icon:"ğŸ”¥", name:"ç«æŠŠ", maxStack:4 },
    bomb:  { icon:"ğŸ’£", name:"ç‚¸è¯åŒ…", maxStack:4 },
    rope:  { icon:"ğŸ§µ", name:"ç»³ç´¢", maxStack:4 }
  };

  // ============ æ¸¸æˆçŠ¶æ€ ============

  const gameState = {
    day: 1,
    lanternRadius: PLAYER_LIGHT_RADIUS,   // å½“å‰æç¯æä¾›çš„è§†é‡åŠå¾„
    lanternDimmed: false,                 // æç¯æ˜¯å¦å·²ç»å˜æš—è¿‡
    nextMonsterId: 1,                     // æ–¹ä¾¿åé¢åŠ¨æ€åˆ·æ€ªç”¨
    turnsLeft: -1,
    maxTurnsPerDay: 200,
    inDungeon: false,
    mode: GameMode.BASE,
    rng: null,
    // â˜… æ–°å¢ï¼šçŸ¿æ´å†…ä»è¿›å…¥å¼€å§‹çš„å›åˆè®¡æ•°
    dungeonTurn: 0,
    // â˜… æ–°å¢ï¼šæç¯å˜æš—é‚£ä¸€å›åˆçš„å›åˆæ•°
    darknessTurn: null,
    base: {
      width: 3,
      height: 3,
      player: {x:1,y:1},
      merchant: false
    },
    dungeon: null,
    dungeonSpawn: {x:0,y:0},
    playerPos: null,
    player: {
      hp: 4,
      maxHp: 5,
      tempHp: 0,
      armor: 2,
      maxArmor: 3,
      stunned: 0,
      facing: {dx:0,dy:-1},
      pickaxe: {
        type: "basic",
        durability: 40,
        maxDurability: 40
      },
      // è£…å¤‡ç±»è®¡æ•°
      charmCharges: 0,
      shieldCharges: 0
    },
    ropeAnchor: null,
    ghostTelegraphs: [],   // å¹½çµå†²åˆºè·¯å¾„é«˜äº®
    slimeTelegraphs: [],   // ç²˜æ¶²æ€ªå¼¹è·³è½ç‚¹é«˜äº®
    hasEnteredDungeonThisDay: false,  // æ–°å¢ï¼šæœ¬æ—¥æ˜¯å¦ä¸‹è¿‡çŸ¿æ´
    monsterMoveAnimTimer: null,        // æ–°å¢ï¼šæ€ªç‰©ç§»åŠ¨åŠ¨ç”»çš„å®šæ—¶å™¨
    monsters: [],
    ghostMoveCounter: 0,
    bombs: [],
    runSeedBase: 0,
    logLines: [],
    inventory: {
      backpack: [],
      chest: []
    }
  };

  function pushLog(msg, important=false) {
    gameState.logLines.push({msg,important});
    if (gameState.logLines.length > 4) {
      gameState.logLines.shift();
    }
    renderLog();
  }

  // ============ èƒŒåŒ… / ç®±å­é€»è¾‘ ============

  function makeEmptyInv(w,h) {
    const arr = [];
    for (let i=0;i<w*h;i++) arr.push(null);
    return arr;
  }

  function addItemToSlots(slots, type, count) {
    const def = ITEM_DEFS[type];
    if (!def || count <= 0) return 0;
    let remain = count;

    // å…ˆå¾€å·²æœ‰åŒç±»å †å 
    for (let i=0;i<slots.length && remain>0;i++) {
      const slot = slots[i];
      if (slot && slot.type === type && slot.count < def.maxStack) {
        const add = Math.min(def.maxStack - slot.count, remain);
        slot.count += add;
        remain -= add;
      }
    }
    // å†æ‰¾ç©ºæ ¼
    for (let i=0;i<slots.length && remain>0;i++) {
      const slot = slots[i];
      if (!slot) {
        const add = Math.min(def.maxStack, remain);
        slots[i] = {type, count:add};
        remain -= add;
      }
    }
    return remain; // å‰©ä½™æ²¡æ”¾è¿›å»çš„æ•°é‡
  }

  function addItem(type, count=1, preferBackpack=true) {
    let remain = count;
    if (preferBackpack) {
      remain = addItemToSlots(gameState.inventory.backpack, type, remain);
      if (remain > 0) remain = addItemToSlots(gameState.inventory.chest, type, remain);
    } else {
      remain = addItemToSlots(gameState.inventory.chest, type, remain);
      if (remain > 0) remain = addItemToSlots(gameState.inventory.backpack, type, remain);
    }
    if (remain > 0) {
      const def = ITEM_DEFS[type];
      pushLog(`èƒŒåŒ…å’Œç®±å­éƒ½æ”¾ä¸ä¸‹ ${def ? def.name : type}ï¼Œæœ‰ ${remain} ä¸ªç•™åœ¨äº†åœ°ä¸Šã€‚`, true);
    }
  }

  function consumeItemFromSlots(slots, type, count=1) {
      let remain = count;
      for (let i=0;i<slots.length && remain>0;i++) {
        const slot = slots[i];
        if (slot && slot.type === type) {
          const use = Math.min(slot.count, remain);
          slot.count -= use;
          remain -= use;
          if (slot.count <= 0) slots[i] = null;
        }
      }
      return remain === 0;
    }

    function consumeItem(type, count = 1, backpackOnly = false) {
    if (backpackOnly) {
      return consumeItemFromSlots(gameState.inventory.backpack, type, count);
    }

    let need = count;

    // å…ˆä»èƒŒåŒ…æ‰£
    const beforeBackpack = getItemCountInSlots(gameState.inventory.backpack, type);
    consumeItemFromSlots(gameState.inventory.backpack, type, need);
    const afterBackpack = getItemCountInSlots(gameState.inventory.backpack, type);
    const usedFromBackpack = Math.min(need, beforeBackpack - afterBackpack);
    need -= usedFromBackpack;

    if (need <= 0) return true;

    // å†ä»ç®±å­æ‰£
    const beforeChest = getItemCountInSlots(gameState.inventory.chest, type);
    const okChest = consumeItemFromSlots(gameState.inventory.chest, type, need);
    if (!okChest) return false;
    const afterChest = getItemCountInSlots(gameState.inventory.chest, type);
    const usedFromChest = beforeChest - afterChest;

    return usedFromChest === need;
  }

  // è¾…åŠ©å‡½æ•°ï¼ˆæ”¾åœ¨é™„è¿‘å³å¯ï¼‰
  function getItemCountInSlots(slots, type) {
    let n = 0;
    for (const s of slots) {
      if (s && s.type === type) n += s.count;
    }
    return n;
  }


  function getItemCount(type) {
    let n = 0;
    for (const slot of [...gameState.inventory.backpack, ...gameState.inventory.chest]) {
      if (slot && slot.type === type) n += slot.count;
    }
    return n;
  }

  function getTotalOre() {
    return getItemCount("ore");
  }

  function spendOre(amount) {
    let total = getTotalOre();
    if (total < amount) return false;
    let remain = amount;
    const lists = [gameState.inventory.backpack, gameState.inventory.chest];
    for (const slots of lists) {
      for (let i=0;i<slots.length && remain>0;i++) {
        const slot = slots[i];
        if (slot && slot.type === "ore") {
          const use = Math.min(slot.count, remain);
          slot.count -= use;
          remain -= use;
          if (slot.count <= 0) slots[i] = null;
        }
      }
    }
    return true;
  }

  // ============ è¿è¡Œ / æ–°ä¸€è½® ============

  function computeTodaySeed(dayOffset=0) {
    const d = new Date();
    const base = d.getFullYear()*10000 + (d.getMonth()+1)*100 + d.getDate();
    return base + dayOffset;
  }

  function resetPlayerFull() {
    gameState.player.hp = 4;
    gameState.player.maxHp = 5;
    gameState.player.tempHp = 1;
    gameState.player.armor = 2;
    gameState.player.maxArmor = 5;
    gameState.player.stunned = 0;
    gameState.player.pickaxe = {
      type: "basic",
      durability: 40,
      maxDurability: 40
    };
    gameState.player.charmCharges = 0;
    gameState.player.shieldCharges = 0;
  }

  function rebuildRngForDay() {
    const seed = gameState.runSeedBase + gameState.day*37;
    gameState.rng = makeRng(seed);
  }

  function updateMerchantForDay() {
    gameState.base.merchant = (gameState.day === 2 || gameState.day === 5 || gameState.day === 8);
  }

  function startNewRun() {
    gameState.runSeedBase = computeTodaySeed();
    gameState.day = 1;
    resetPlayerFull();
    gameState.hasEnteredDungeonThisDay = false; // æ–°å¢
    gameState.inventory.backpack = makeEmptyInv(INV_BACKPACK_W, INV_BACKPACK_H);
    gameState.inventory.chest = makeEmptyInv(INV_CHEST_W, INV_CHEST_H);
    // åˆå§‹ 2 ä¸ªé¢åŒ…åœ¨ç®±å­é‡Œ
    addItemToSlots(gameState.inventory.chest, "bread", 2);

    gameState.base.player = {x:1,y:1};
    gameState.mode = GameMode.BASE;
    gameState.inDungeon = false;
    gameState.turnsLeft = -1;
    gameState.logLines = [];
    gameState.bombs = [];
    gameState.ropeAnchor = null;
    pushLog("ä½ åœ¨ä¸´æ—¶åŸºåœ°ä¸­é†’æ¥ã€‚");
    rebuildRngForDay();
    updateMerchantForDay();
    renderAll();
  }

  function startNewDay() {
    gameState.day += 1;
    if (gameState.day >= 10) {
      showDemoEnd();
      return;
    }
    gameState.hasEnteredDungeonThisDay = false; // æ–°å¢
    // ç¡è§‰æ¢å¤ 1 ç‚¹çœŸå®ç”Ÿå‘½ï¼Œå¦åˆ™ +1 ä¸´æ—¶ç”Ÿå‘½
    if (gameState.player.hp < gameState.player.maxHp) {
      gameState.player.hp += 1;
    } else {
      gameState.player.tempHp += 1;
    }

    gameState.base.player = {x:1,y:1};
    gameState.mode = GameMode.BASE;
    gameState.inDungeon = false;
    gameState.turnsLeft = -1;
    gameState.logLines = [];
    gameState.bombs = [];
    gameState.ropeAnchor = null;
    rebuildRngForDay();
    updateMerchantForDay();
    pushLog("æ–°çš„ä¸€å¤©å¼€å§‹äº†ã€‚");
    renderAll();
  }

  // ============ åœ°ä¸‹ç”Ÿæˆï¼ˆç©ºæ´ + çŸ¿ç‰© + æ€ªç‰©ï¼‰ ============

  function generateDungeon() {
    const width = 28, height = 28;
    const tiles = [];
    for (let y = 0; y < height; y++) {
      const row = [];
      for (let x = 0; x < width; x++) {
        row.push({
          type: TILE_ROCK,
          discovered: false,
          visible: false,
          hasTorch: false,
          lastSeenTurn: null
        });
      }
      tiles.push(row);
    }

    const rng = gameState.rng;

    // ===== å‡ºç”Ÿç‚¹ & 3Ã—3 å®‰å…¨åŒº =====
    const spawnX = Math.floor(width / 2);
    const spawnY = Math.floor(height / 2);
    gameState.dungeonSpawn = { x: spawnX, y: spawnY };
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const x = spawnX + dx;
        const y = spawnY + dy;
        if (x < 0 || x >= width || y < 0 || y >= height) continue;
        tiles[y][x].type = TILE_FLOOR;
      }
    }
    tiles[spawnY][spawnX].type = TILE_STAIR_UP; // å‡ºç”Ÿç‚¹ä½œä¸ºæ¥¼æ¢¯

    function chebDist(x1, y1, x2, y2) {
      return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2));
    }
    function manhattan(x1, y1, x2, y2) {
      return Math.abs(x1 - x2) + Math.abs(y1 - y2);
    }

    // ===== æ´çªŸï¼ˆç©ºæ´ï¼‰ç”Ÿæˆï¼šæ•°é‡å¤šä¸€ç‚¹ï¼Œæ•´ä½“è¿œç¦»å‡ºç”Ÿç‚¹ =====
    const caves = [];
    const caveCount = 5;             // ä»¥å‰æ˜¯ 3ï¼Œç°åœ¨å¤šä¸€ç‚¹
    const minCaveDistFromSpawn = 8;  // æ´çªŸæ•´ä½“å°½é‡è¿œç¦»å‡ºç”Ÿç‚¹

    for (let ci = 0; ci < caveCount; ci++) {
      let cx = 0, cy = 0;
      let attempts = 0;
      let foundCenter = false;

      while (attempts < 80 && !foundCenter) {
        cx = randInt(rng, 2, width - 3);
        cy = randInt(rng, 2, height - 3);
        const radius = randInt(rng, 1, 3);

        if (chebDist(cx, cy, spawnX, spawnY) < minCaveDistFromSpawn + radius) {
          attempts++;
          continue;
        }
        foundCenter = true;
      }

      if (!foundCenter) continue;

      const radius = randInt(rng, 1, 3);
      const candidates = [];
      for (let y = cy - radius; y <= cy + radius; y++) {
        for (let x = cx - radius; x <= cx + radius; x++) {
          if (x < 0 || x >= width || y < 0 || y >= height) continue;
          if (chebDist(x, y, spawnX, spawnY) < minCaveDistFromSpawn) continue;
          const dx = x - cx;
          const dy = y - cy;
          if (dx * dx + dy * dy <= radius * radius + 1 &&
              tiles[y][x].type === TILE_ROCK) {
            candidates.push({ x, y });
          }
        }
      }
      if (!candidates.length) continue;

      shuffle(rng, candidates);
      const desiredSize = randInt(rng, 10, 20);  // æ¯”ä¹‹å‰ç¨å¾®å¤šä¸€ç‚¹
      const actualSize = Math.min(desiredSize, candidates.length);
      const caveCells = [];
      for (let i = 0; i < actualSize; i++) {
        const { x, y } = candidates[i];
        tiles[y][x].type = TILE_HOLE;
        caveCells.push({ x, y });
      }
      if (caveCells.length > 0) {
        caves.push({ cells: caveCells });
      }
    }

    // ===== æ—§çŸ¿é“ï¼šä»å‡ºç”Ÿç‚¹å‘å¤–éšæœºè”“å»¶ï¼Œä¸åˆ»æ„è”é€šæ´çªŸ =====
    function carveOldMinesFromSpawn() {
      const pathCount = randInt(rng, 2, 3);       // 2~3 æ¡æ—§çŸ¿é“
      const baseDirs = [
        { dx: 1, dy: 0 },
        { dx: -1, dy: 0 },
        { dx: 0, dy: 1 },
        { dx: 0, dy: -1 }
      ];

      for (let i = 0; i < pathCount; i++) {
        let x = spawnX;
        let y = spawnY;

        // é€‰ä¸€ä¸ªåˆå§‹æ–¹å‘ï¼Œå°½é‡å‘åœ°å›¾è¾¹ç¼˜
        let mainDir = baseDirs[randInt(rng, 0, baseDirs.length - 1)];
        const steps = randInt(rng, 7, 13);        // æ¯æ¡æŒ– 7~13 æ­¥

        for (let s = 0; s < steps; s++) {
          // å¶å°”æ‹å¼¯ï¼Œé¿å…æ­»ç›´çº¿
          if (rng() < 0.25) {
            mainDir = baseDirs[randInt(rng, 0, baseDirs.length - 1)];
          }
          const nx = x + mainDir.dx;
          const ny = y + mainDir.dy;
          if (nx < 1 || nx >= width - 1 || ny < 1 || ny >= height - 1) break;

          x = nx;
          y = ny;

          // ä¸ä¸»åŠ¨æŠŠæ´çªŸæ”¹æ‰ï¼šæ—§çŸ¿é“åªæ˜¯ã€Œé€šå‘è¿œå¤„ã€çš„å¦ä¸€å±‚ç»“æ„
          if (tiles[y][x].type === TILE_HOLE) continue;

          if (tiles[y][x].type === TILE_ROCK || tiles[y][x].type === TILE_ORE) {
            tiles[y][x].type = TILE_FLOOR;
          }
        }
      }
    }
    carveOldMinesFromSpawn();

    // ===== çŸ¿è„‰ & æ•£çŸ¿ï¼šè¿œç¦»å‡ºç”Ÿç‚¹ï¼ŒçŸ¿è„‰ä¹‹é—´ä¿æŒè·ç¦» =====
    const oreForbidden = [];
    for (let y = 0; y < height; y++) {
      const row = new Array(width).fill(false);
      oreForbidden.push(row);
    }
    function markOreForbiddenAround(cells) {
      for (const c of cells) {
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            const nx = c.x + dx;
            const ny = c.y + dy;
            if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
            oreForbidden[ny][nx] = true;
          }
        }
      }
    }

    const minOreDistFromSpawn = 6; // çŸ¿è„‰æ•´ä½“è‡³å°‘ç¦»å‡ºç”Ÿç‚¹è¿™ä¹ˆè¿œ

    // ---- çŸ¿è„‰ï¼ˆè¿é€šå—ï¼‰ ----
    const veinCount = randInt(rng, 3, 5);
    for (let v = 0; v < veinCount; v++) {
      let tries = 0;
      let start = null;

      while (tries < 80 && !start) {
        const x = randInt(rng, 0, width - 1);
        const y = randInt(rng, 0, height - 1);
        const t = tiles[y][x].type;
        if (t !== TILE_ROCK) { tries++; continue; }
        if (oreForbidden[y][x]) { tries++; continue; }
        if (chebDist(x, y, spawnX, spawnY) < minOreDistFromSpawn) { tries++; continue; }
        start = { x, y };
      }
      if (!start) continue;

      const targetSize = randInt(rng, 8, 12);
      const frontier = [start];
      const veinCells = [];
      const used = new Set();
      used.add(`${start.x},${start.y}`);

      while (frontier.length && veinCells.length < targetSize) {
        const idx = randInt(rng, 0, frontier.length - 1);
        const { x, y } = frontier[idx];

        // ä¿è¯çŸ¿è„‰æ•´ä½“ä¹Ÿè¿œç¦»å‡ºç”Ÿç‚¹
        if (!oreForbidden[y][x] &&
            tiles[y][x].type === TILE_ROCK &&
            chebDist(x, y, spawnX, spawnY) >= minOreDistFromSpawn) {
          veinCells.push({ x, y });
        }

        const dirs = [
          { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
          { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
        ];
        shuffle(rng, dirs);
        let expanded = false;

        for (const dDir of dirs) {
          const nx = x + dDir.dx;
          const ny = y + dDir.dy;
          if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
          const key = `${nx},${ny}`;
          if (used.has(key)) continue;
          if (tiles[ny][nx].type !== TILE_ROCK) continue;
          if (oreForbidden[ny][nx]) continue;
          if (chebDist(nx, ny, spawnX, spawnY) < minOreDistFromSpawn) continue;
          used.add(key);
          frontier.push({ x: nx, y: ny });
          expanded = true;
          if (veinCells.length >= targetSize) break;
        }

        if (!expanded) {
          frontier.splice(idx, 1);
        }
      }

      if (veinCells.length < 6) continue;

      for (const c of veinCells) {
        tiles[c.y][c.x].type = TILE_ORE;
      }
      markOreForbiddenAround(veinCells);
    }

    // ---- æ•£è½çš„å°çŸ¿çŸ³ ----
    let singleOres = randInt(rng, 10, 20);
    let guard = 0;
    while (singleOres > 0 && guard < 300) {
      guard++;
      const x = randInt(rng, 0, width - 1);
      const y = randInt(rng, 0, height - 1);
      if (tiles[y][x].type !== TILE_ROCK) continue;
      if (oreForbidden[y][x]) continue;
      if (chebDist(x, y, spawnX, spawnY) < minOreDistFromSpawn) continue;

      tiles[y][x].type = TILE_ORE;
      markOreForbiddenAround([{ x, y }]);
      singleOres--;
    }

    // ===== å®ç®± =====
    const openCells = [];
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const t = tiles[y][x].type;
        if ((t === TILE_FLOOR || t === TILE_HOLE) &&
            !(Math.abs(x - spawnX) <= 1 && Math.abs(y - spawnY) <= 1)) {
          openCells.push({ x, y });
        }
      }
    }
    shuffle(rng, openCells);
    const chestCount = 2;
    for (let i = 0; i < chestCount && i < openCells.length; i++) {
      const pos = openCells[i];
      tiles[pos.y][pos.x].type = TILE_CHEST;
    }

    // æ¯ä¸ªæ´é‡Œè‡³å°‘ä¸€ä¸ªå®ç®±
    caves.forEach(cave => {
      if (!cave.cells.length) return;
      const candidates = cave.cells.filter(c =>
        !(Math.abs(c.x - spawnX) <= 1 && Math.abs(c.y - spawnY) <= 1)
      );
      if (!candidates.length) return;
      const pick = candidates[randInt(rng, 0, candidates.length - 1)];
      tiles[pick.y][pick.x].type = TILE_CHEST;
    });

    // ===== æ€ªç‰©ç”Ÿæˆï¼ˆåŸºæœ¬ä¿æŒä½ åŸæ¥çš„é€»è¾‘ï¼‰ =====
    const caveZombieSpawns = [];
    caves.forEach(cave => {
      const candidates = cave.cells.filter(c => {
        const t = tiles[c.y][c.x].type;
        if (t === TILE_CHEST) return false;
        if (Math.abs(c.x - spawnX) <= 1 && Math.abs(c.y - spawnY) <= 1) return false;
        return true;
      });
      shuffle(rng, candidates);
      for (let i = 0; i < 2 && i < candidates.length; i++) {
        caveZombieSpawns.push(candidates[i]);
      }
    });

    const rockCells = [];
    const walkCells = [];
    const occupied = new Set(
      caveZombieSpawns.map(p => `${p.x},${p.y}`)
    );

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const t = tiles[y][x].type;

        if (Math.abs(x - spawnX) <= 1 && Math.abs(y - spawnY) <= 1) continue;
        if (occupied.has(`${x},${y}`)) continue;
        if (t === TILE_CHEST) continue;

        const distFromSpawn = manhattan(x, y, spawnX, spawnY);

        if (t === TILE_ROCK) {
          rockCells.push({ x, y });
        } else if (t === TILE_HOLE) {
          walkCells.push({ x, y });
        } else if (t === TILE_FLOOR) {
          if (distFromSpawn >= 6) {
            walkCells.push({ x, y });
          }
        }
      }
    }
    shuffle(rng, rockCells);
    shuffle(rng, walkCells);

    const ghostSpots = [];
    const otherWalkSpots = [];
    for (const p of walkCells) {
      const dist = manhattan(p.x, p.y, spawnX, spawnY);
      if (dist >= 8) ghostSpots.push(p);
      else otherWalkSpots.push(p);
    }
    shuffle(rng, ghostSpots);
    shuffle(rng, otherWalkSpots);

    const monsters = [];
    let nextId = 1;

    // æ´å†…å›ºå®šåƒµå°¸
    for (const pos of caveZombieSpawns) {
      monsters.push({
        id: nextId++,
        type: MON_ZOMBIE,
        x: pos.x,
        y: pos.y,
        alive: true,
        buried: false,
        wakeDelay: 0,
        homeX: pos.x,
        homeY: pos.y,
        roamRadius: 0,
        attackCooldown: 0,
        charging: false,
        attackType: null,
        chargePath: null,
        chargeDir: null,
        chargeTarget: null
      });
    }

    const maxSpots = rockCells.length + ghostSpots.length + otherWalkSpots.length;
    const extraCount = Math.min(randInt(rng, 14, 20), maxSpots);
    let ghostCount = 0;
    const maxGhosts = 4;

    for (let i = 0; i < extraCount; i++) {
      let roll = rng();
      let type;

      if (roll < 0.5) type = MON_ZOMBIE;
      else if (roll < 0.8) type = MON_SLIME;
      else type = MON_GHOST;

      if (type === MON_GHOST && ghostCount >= maxGhosts) {
        type = (roll < 0.65 ? MON_ZOMBIE : MON_SLIME);
      }

      let pos;
      if (type === MON_GHOST) {
        if (ghostSpots.length) {
          pos = ghostSpots.pop();
        } else if (otherWalkSpots.length) {
          pos = otherWalkSpots.pop();
        } else if (rockCells.length) {
          pos = rockCells.pop();
        }
      } else {
        if (rockCells.length) {
          pos = rockCells.pop();
        } else if (otherWalkSpots.length) {
          pos = otherWalkSpots.pop();
        } else if (ghostSpots.length) {
          pos = ghostSpots.pop();
        }
      }

      if (!pos) {
        if (rockCells.length && rng() < 0.6) {
          pos = rockCells.pop();
        } else if (otherWalkSpots.length) {
          pos = otherWalkSpots.pop();
        } else if (ghostSpots.length) {
          pos = ghostSpots.pop();
        } else if (rockCells.length) {
          pos = rockCells.pop();
        }
      }

      if (!pos) break;

      const tileType = tiles[pos.y][pos.x].type;
      const buried = (tileType === TILE_ROCK && type !== MON_GHOST);

      monsters.push({
        id: nextId++,
        type,
        x: pos.x,
        y: pos.y,
        alive: true,
        buried,
        wakeDelay: 0,
        homeX: pos.x,
        homeY: pos.y,
        roamRadius: type === MON_GHOST ? 2 : 0,
        attackCooldown: (type === MON_SLIME || type === MON_GHOST)
          ? randInt(rng, 0, 6)
          : 0,
        charging: false,
        attackType: null,
        chargePath: null,
        chargeDir: null,
        chargeTarget: null
      });

      if (type === MON_GHOST) ghostCount++;
    }

    // ===== å¯è§æ€§åˆå§‹åŒ– =====
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        tiles[y][x].discovered = false;
        tiles[y][x].visible = false;
        tiles[y][x].hasTorch = false;
        tiles[y][x].lastSeenTurn = null; // â˜… æ–°å¢
      }
    }

    gameState.dungeon = { width, height, tiles };
    gameState.monsters = monsters;
    gameState.nextMonsterId = monsters.reduce(
      (max, m) => m.id > max ? m.id : max,
      0
    ) + 1;
    gameState.bombs = [];
    gameState.ropeAnchor = null;
    gameState.ghostMoveCounter = 0;
    gameState.ghostTelegraphs = [];
    gameState.slimeTelegraphs = [];
  }





  function updateVisibility() {
    if (!gameState.inDungeon || !gameState.dungeon || !gameState.playerPos) return;
    const d = gameState.dungeon;
    const w = d.width, h = d.height;

    // æ¸…ç©º visible
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        d.tiles[y][x].visible = false;
      }
    }

    const sources = [];
    // ç©å®¶å…‰æº
    const playerLight = gameState.lanternRadius || PLAYER_LIGHT_RADIUS;
    sources.push({
      x: gameState.playerPos.x,
      y: gameState.playerPos.y,
      r: playerLight
    });
    // ç«æŠŠå…‰æº
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        if (d.tiles[y][x].hasTorch) {
          sources.push({ x, y, r: 3 });
        }
      }
    }

    for (const src of sources) {
      const minX = Math.max(0, src.x - src.r - 1);
      const maxX = Math.min(w - 1, src.x + src.r + 1);
      const minY = Math.max(0, src.y - src.r - 1);
      const maxY = Math.min(h - 1, src.y + src.r + 1);

      for (let y = minY; y <= maxY; y++) {
        for (let x = minX; x <= maxX; x++) {
          const cheb = Math.max(Math.abs(x - src.x), Math.abs(y - src.y));
          if (cheb > src.r) continue;
          if (!hasLineOfSight(src.x, src.y, x, y, false)) continue;
          const tile = d.tiles[y][x];
          tile.visible = true;
          tile.discovered = true;
          tile.lastSeenTurn = gameState.dungeonTurn;
        }
      }
    }
     // â˜… æ–°å¢ï¼šé™¤äº†å‡ºç”Ÿç‚¹å¤–ï¼Œ8 å›åˆæ²¡å†çœ‹åˆ°å°±â€œé—å¿˜â€è§†é‡ï¼ˆdiscovered å˜å› falseï¼‰
    if (gameState.dungeonTurn != null) {
      const spawn = gameState.dungeonSpawn;
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const tile = d.tiles[y][x];
          if (!tile.discovered || tile.visible) continue;

          // å‡ºç”Ÿç‚¹æ°¸ä¹…ä¿ç•™æ¢ç´¢
          if (spawn && x === spawn.x && y === spawn.y) continue;

          const last = tile.lastSeenTurn;
          if (last != null && gameState.dungeonTurn - last >= 8) {
            tile.discovered = false;
          }
        }
      }
    }
  }


  // ============ æ¸²æŸ“ ============

  function renderHUD() {
    document.getElementById("hud-day").textContent = gameState.day;
    document.getElementById("hud-turns").textContent = gameState.inDungeon ? gameState.turnsLeft : "-";
    document.getElementById("hud-ore").textContent = getTotalOre();

    const heartsEl = document.getElementById("hud-hearts");
    heartsEl.innerHTML = "";
    const hp = gameState.player.hp;
    const maxHp = gameState.player.maxHp;
    const tempHp = gameState.player.tempHp;
    for (let i=0;i<maxHp;i++) {
      const span = document.createElement("span");
      if (i < hp) {
        span.textContent = "â¤ï¸";
      } else if (i < hp + tempHp) {
        span.textContent = "ğŸ’›";
      } else {
        span.textContent = "ğŸ–¤";
      }
      heartsEl.appendChild(span);
    }

    const armorEl = document.getElementById("hud-armor");
    armorEl.innerHTML = "";
    for (let i=0;i<gameState.player.maxArmor;i++) {
      const span = document.createElement("span");
      if (i < gameState.player.armor) {
        span.textContent = "ğŸ›¡ï¸";
      } else {
        span.textContent = "â¬œ";
      }
      armorEl.appendChild(span);
    }

    const pickaxe = gameState.player.pickaxe;
    const pickaxeEl = document.getElementById("hud-pickaxe");
    pickaxeEl.textContent = `${pickaxe.durability}/${pickaxe.maxDurability}`;
    if (pickaxe.durability <= 0) pickaxeEl.classList.add("text-danger");
    else pickaxeEl.classList.remove("text-danger");

    // side stats
    document.getElementById("tag-location").textContent =
      gameState.mode === GameMode.BASE ? "åŸºåœ°" : "çŸ¿æ´";
    document.getElementById("stat-loc-text").textContent =
      gameState.mode === GameMode.BASE ? "ä¸´æ—¶åŸºåœ°" : "åœ°åº•é€šé“";
    document.getElementById("stat-temp-hp").textContent = gameState.player.tempHp;
    document.getElementById("stat-stun").textContent = gameState.player.stunned;
    document.getElementById("stat-monsters").textContent =
      gameState.monsters.filter(m=>m.alive).length;
    document.getElementById("stat-charm").textContent = gameState.player.charmCharges;
    document.getElementById("stat-shield").textContent = gameState.player.shieldCharges;

    document.getElementById("stat-bread").textContent = getItemCount("bread");
    document.getElementById("stat-torch").textContent = getItemCount("torch");
    document.getElementById("stat-bomb").textContent = getItemCount("bomb");
    document.getElementById("stat-rope").textContent = getItemCount("rope");

    renderBackpackMini();
  }

  function renderBackpackMini() {
    const grid = document.getElementById("backpack-grid");
    grid.innerHTML = "";
    const slots = gameState.inventory.backpack;
    for (let i=0;i<slots.length;i++) {
      const slot = slots[i];
      const div = document.createElement("div");
      div.className = "inv-slot";
      if (!slot) {
        div.classList.add("inv-slot-empty");
        div.textContent = "";
      } else {
        const def = ITEM_DEFS[slot.type];
        div.textContent = def ? def.icon : "?";
        if (slot.count > 1) {
          const c = document.createElement("span");
          c.className = "inv-count";
          c.textContent = slot.count;
          div.appendChild(c);
        }
      }
      grid.appendChild(div);
    }
  }

  function renderLog() {
    const panel = document.getElementById("log-panel");
    panel.innerHTML = "";
    gameState.logLines.forEach(line => {
      const div = document.createElement("div");
      div.className = "log-line" + (line.important ? " important" : "");
      div.textContent = "Â· " + line.msg;
      panel.appendChild(div);
    });
  }

  function renderBase() {
    const baseView = document.getElementById("base-view");
    const dungeonView = document.getElementById("dungeon-view");
    if (gameState.mode === GameMode.BASE) {
      baseView.classList.remove("hidden");
      dungeonView.classList.add("hidden");
    } else {
      baseView.classList.add("hidden");
      dungeonView.classList.remove("hidden");
      return;
    }

    baseView.innerHTML = "";
    const w = gameState.base.width;
    const h = gameState.base.height;

    for (let y=0;y<h;y++) {
      for (let x=0;x<w;x++) {
        const tile = document.createElement("div");
        tile.className = "tile base";

        let symbol = "";
        // (0,1) ç®±å­, (2,1) åºŠ, (1,2) åœ°é“å…¥å£, (2,0) å•†äºº
        if (x === 0 && y === 1) {
          symbol = "ğŸ“¦";
          tile.classList.add("chest");
        }
        if (x === 2 && y === 1) {
          symbol = "ğŸ›ï¸";
          tile.classList.add("bed");
        }
        if (x === 1 && y === 2) {
          symbol = "â¬‡ï¸";
          tile.classList.add("stairs");
        }
        if (gameState.base.merchant && x === 2 && y === 0) {
          symbol = "ğŸ§™â€â™‚ï¸";
          tile.classList.add("merchant");
        }

        if (gameState.base.player.x === x && gameState.base.player.y === y) {
          tile.classList.add("player");
          symbol = "â›ï¸";
        }

        tile.textContent = symbol;
        baseView.appendChild(tile);
      }
    }
  }

  function renderDungeon() {
    if (gameState.mode !== GameMode.DUNGEON || !gameState.dungeon) return;
    const baseView = document.getElementById("base-view");
    const dungeonView = document.getElementById("dungeon-view");
    baseView.classList.add("hidden");
    dungeonView.classList.remove("hidden");
    dungeonView.innerHTML = "";

    const dungeon = gameState.dungeon;
    const width = dungeon.width;
    const height = dungeon.height;
    const spawn = gameState.dungeonSpawn;

    for (let y=0;y<height;y++) {
      for (let x=0;x<width;x++) {
        const tileData = dungeon.tiles[y][x];
        const tile = document.createElement("div");
        let classes = ["tile","dungeon"];
        let symbol = "";

        // æœªæ¢ç´¢ & ä¸å¯è§ => å®Œå…¨é»‘
        if (!tileData.discovered && !tileData.visible) {
          classes.push("fog");
          tile.className = classes.join(" ");
          dungeonView.appendChild(tile);
          continue;
        }

        // åœ°å½¢
        switch(tileData.type) {
          case TILE_ROCK:
            classes.push("rock");
            symbol = "ğŸª¨";
            break;
          case TILE_FLOOR:
            classes.push("floor");
            break;
          case TILE_ORE:
            classes.push("ore");
            symbol = "â›ï¸";
            break;
          case TILE_HOLE:
            classes.push("hole");
            break;
          case TILE_STAIR_UP:
            classes.push("stair-up");
            symbol = "â¬†ï¸";
            break;
          case TILE_CHEST:
            classes.push("chest");
            symbol = "ğŸ’°";
            break;
        }

        if (!tileData.visible) {
          classes.push("dim");
        }

        // å‡ºç”Ÿç‚¹é«˜äº®
        if (spawn && x === spawn.x && y === spawn.y) {
          classes.push("spawn");
        }

        // å¹½çµå†²åˆº / ç²˜æ¶²æ€ªè·³è·ƒé¢„è­¦
        if (gameState.ghostTelegraphs.some(p => p.x === x && p.y === y)) {
          classes.push("ghost-tele");
        }
        if (gameState.slimeTelegraphs.some(p => p.x === x && p.y === y)) {
          classes.push("slime-tele");
        }

        let mon = null;
        let bombHere = null;

        // æ€ªç‰© / ç‚¸è¯ / ç©å®¶ï¼Œåªæ˜¾ç¤ºåœ¨å¯è§èŒƒå›´å†…
        if (tileData.visible) {
          mon = gameState.monsters.find(m => m.alive && !m.buried && m.x === x && m.y === y);
          if (mon) {
            classes.push("monster");
            if (mon.type === MON_ZOMBIE) {
              symbol = "ğŸ§Ÿ";
            } else if (mon.type === MON_SLIME) {
              symbol = "ğŸŸ¢";
            } else if (mon.type === MON_GHOST) {
              symbol = "ğŸ‘»";
            }
            // â˜… æ–°å¢ï¼šæ ¹æ® charging çŠ¶æ€åŠ ç±»
            if (mon.charging && mon.attackType === "dash" && mon.type === MON_GHOST) {
              classes.push("mon-ghost-charging");
            }
            if (mon.charging && mon.attackType === "jump" && mon.type === MON_SLIME) {
              classes.push("mon-slime-charging");
            }
            if (mon.justMoved) {
              classes.push("monster-moving");
            }
          }

          bombHere = gameState.bombs.find(b=>b.x===x && b.y===y);
          if (bombHere) {
            classes.push("bomb");
            symbol = "ğŸ’£";
          }

          if (gameState.playerPos &&
              gameState.playerPos.x === x &&
              gameState.playerPos.y === y) {
            classes.push("player");
            symbol = "â›ï¸";
          }
        }

        // åœ¨æ²¡æœ‰æ€ª / ç‚¸è¯ / ç©å®¶æ—¶æ˜¾ç¤ºç«æŠŠ / ç»³ç´¢ emoji
        if (tileData.visible && !mon && !bombHere &&
            !(gameState.playerPos && gameState.playerPos.x === x && gameState.playerPos.y === y)) {
          if (gameState.ropeAnchor &&
              gameState.ropeAnchor.x === x &&
              gameState.ropeAnchor.y === y) {
            symbol = "ğŸ§µ";
          } else if (tileData.hasTorch) {
            symbol = "ğŸ”¥";
          }
        }

        tile.className = classes.join(" ");
        tile.textContent = symbol;
        dungeonView.appendChild(tile);
      }
    }
  }



  function renderAll() {
    renderHUD();
    renderBase();
    renderDungeon();
    renderLog();
  }

  // ============ å•†äºº ============

  const modalMerchant = document.getElementById("modal-merchant");
  const shopListEl = document.getElementById("shop-list");

  function openMerchant() {
    buildShopForToday();
    document.getElementById("shop-ore").textContent = getTotalOre();
    modalMerchant.classList.remove("hidden");
  }

  function closeMerchant() {
    modalMerchant.classList.add("hidden");
    renderAll();
  }

  document.getElementById("btn-shop-close").addEventListener("click", closeMerchant);
  modalMerchant.querySelector(".modal-backdrop").addEventListener("click", closeMerchant);

  function buildShopForToday() {
    shopListEl.innerHTML = "";
    const day = gameState.day;
    const items = [];

    // é€šç”¨
    items.push({
      id: "bread",
      name: "é¢åŒ… ğŸ",
      price: 1,
      desc: "åƒæ‰åå›å¤ 1 ç‚¹ç”Ÿå‘½ï¼ˆä¼˜å…ˆçœŸå®ç”Ÿå‘½ï¼‰ã€‚",
      type: "consumable"
    });
    items.push({
      id: "armor",
      name: "æŠ¤ç”² 4/4 ğŸ›¡ï¸",
      price: 5,
      desc: "æ›¿æ¢å½“å‰æŠ¤ç”²ä¸º 4/4ï¼ŒæŒ¡ä¼¤å®³ä¼˜å…ˆæ¶ˆè€—æŠ¤ç”²ã€‚",
      type: "armor"
    });
    items.push({
      id: "pickaxe_basic",
      name: "æ™®é€šç¨¿å­ 40/40 â›ï¸",
      price: 10,
      desc: "æ›¿æ¢å½“å‰ç¨¿å­ä¸º 40/40ã€‚",
      type: "pickaxe"
    });

    if (day >= 2) {
      items.push({
        id: "torch",
        name: "ç«æŠŠ ğŸ”¥",
        price: 2,
        desc: "æ’åœ¨åœ°é¢ä¸Šæä¾›é¢å¤–å…‰ç…§ã€‚",
        type: "torch"
      });
    }

    if (day >= 5) {
      items.push({
        id: "pickaxe_light",
        name: "è½»ä¾¿ç¨¿å­ 30/30 ğŸª“",
        price: 7,
        desc: "æ›´è½»ä¾¿,ä¹Ÿæ›´ä¾¿å®œã€‚",
        pickaxe: {type:"light",dur:30},
        type: "pickaxe"
      });
      items.push({
        id: "pickaxe_heavy",
        name: "é‡å‹ç¨¿å­ 55/55 âš’ï¸",
        price: 15,
        desc: "æ›´è€ç”¨çš„é‡å‹å·¥å…·ã€‚",
        pickaxe: {type:"heavy",dur:55},
        type: "pickaxe"
      });
      items.push({
        id: "helmet",
        name: "çŸ¿å·¥å¤´ç›” â›‘ï¸",
        price: 8,
        desc: "æä¾› +1 æŠ¤ç”²è€ä¹…ï¼ŒæŠ¤ç”²å…¨éƒ¨æŸåæ—¶å¤´ç›”ä¼šç ´ç¢ã€‚",
        type: "helmet"
      });
      items.push({
        id: "shield",
        name: "å°–åˆºç›¾ç‰Œ ğŸ›¡ï¸",
        price: 6,
        desc: "é¦–æ¬¡è¢«åƒµå°¸æˆ–ç²˜æ¶²æ€ªè´´è„¸æ”»å‡»æ—¶ï¼Œç›´æ¥åå‡»ç§’æ€å¯¹æ–¹å¹¶å…ç–«è¿™æ¬¡ä¼¤å®³ã€‚",
        type: "shield"
      });
    }

    if (day >= 8) {
      items.push({
        id: "pickaxe_magic",
        name: "é­”æ³•ç¨¿å­ 50/50 âœ¨",
        price: 18,
        desc: "å‡»æ€æ€ªç‰©æ—¶æœ‰å°æ¦‚ç‡é¢å¤–æ‰çŸ¿çŸ³ã€‚",
        pickaxe: {type:"magic",dur:50},
        type: "pickaxe"
      });
      items.push({
        id: "bomb",
        name: "ç‚¸è¯åŒ… ğŸ’£",
        price: 5,
        desc: "ä¸‰å›åˆååœ¨ 3Ã—3 åŒºåŸŸçˆ†ç‚¸ï¼Œç‚¸å¼€å²©çŸ³å¹¶ä¼¤å®³æ€ªç‰©ã€‚",
        type: "bomb"
      });
      items.push({
        id: "rope",
        name: "ç»³ç´¢ ğŸ§µ",
        price: 4,
        desc: "å¯ä»¥è®¾ç½®ä¸€ä¸ªé”šç‚¹ï¼Œå†æ¬¡ä½¿ç”¨æ—¶ç¬ç§»å›é”šç‚¹ã€‚",
        type: "rope"
      });
      items.push({
        id: "charm",
        name: "å¹½çµä¹‹çœ¼æŠ¤ç¬¦ ğŸ‘ï¸",
        price: 7,
        desc: "å¹½çµåœ¨è¿œå¤„æ—¶ä¸ä¼šä¸»åŠ¨é è¿‘ä½ ï¼Œè´´è„¸æ”»å‡»æ—¶æŠ¤ç¬¦ç¢è£‚ã€‚",
        type: "charm"
      });
    }

    items.forEach(item => {
      const row = document.createElement("div");
      row.className = "shop-item";

      const left = document.createElement("div");
      const name = document.createElement("div");
      name.className = "shop-name";
      name.textContent = item.name;
      const desc = document.createElement("div");
      desc.className = "shop-desc";
      desc.textContent = item.desc;
      left.appendChild(name);
      left.appendChild(desc);

      const right = document.createElement("div");
      const price = document.createElement("div");
      price.innerHTML = `<span class="text-good">${item.price}</span> çŸ¿çŸ³`;
      const btn = document.createElement("button");
      btn.className = "btn";
      btn.style.padding = "2px 8px";
      btn.style.fontSize = "11px";
      btn.textContent = "è´­ä¹°";
      btn.addEventListener("click", () => {
        buyShopItem(item);
      });
      right.appendChild(price);
      right.appendChild(btn);

      row.appendChild(left);
      row.appendChild(right);
      shopListEl.appendChild(row);
    });
  }

  function buyShopItem(item) {
    if (!spendOre(item.price)) {
      pushLog("çŸ¿çŸ³ä¸å¤Ÿã€‚", true);
      document.getElementById("shop-ore").textContent = getTotalOre();
      return;
    }
    document.getElementById("shop-ore").textContent = getTotalOre();

    switch(item.type) {
      case "consumable":
        addItem("bread",1,true);
        pushLog("ä¹°åˆ°äº†é¢åŒ…ã€‚");
        break;
      case "armor":
        gameState.player.maxArmor = 4;
        gameState.player.armor = 4;
        pushLog("æ¢ä¸Šäº†æ–°çš„æŠ¤ç”²ã€‚");
        break;
      case "pickaxe":
        if (item.pickaxe) {
          gameState.player.pickaxe.type = item.pickaxe.type;
          gameState.player.pickaxe.maxDurability = item.pickaxe.dur;
          gameState.player.pickaxe.durability = item.pickaxe.dur;
        } else {
          gameState.player.pickaxe.type = "basic";
          gameState.player.pickaxe.maxDurability = 40;
          gameState.player.pickaxe.durability = 40;
        }
        pushLog("æ¢ä¸Šäº†æ–°çš„ç¨¿å­ã€‚");
        break;
      case "torch":
        addItem("torch",1,true);
        pushLog("æ‹¿åˆ°äº†ä¸€æ”¯ç«æŠŠã€‚");
        break;
      case "helmet":
        gameState.player.maxArmor += 1;
        gameState.player.armor += 1;
        pushLog("æˆ´ä¸Šäº†çŸ¿å·¥å¤´ç›”ã€‚");
        break;
      case "shield":
        gameState.player.shieldCharges += 1;
        pushLog("æ‹¿åˆ°äº†å°–åˆºç›¾ç‰Œã€‚");
        break;
      case "bomb":
        addItem("bomb",1,true);
        pushLog("ä¹°äº†ä¸€ä¸ªç‚¸è¯åŒ…ã€‚");
        break;
      case "rope":
        addItem("rope",1,true);
        pushLog("æ”¶ä¸‹äº†ä¸€æ ¹ç»³ç´¢ã€‚");
        break;
      case "charm":
        gameState.player.charmCharges += 1;
        pushLog("ä½©æˆ´äº†å¹½çµä¹‹çœ¼æŠ¤ç¬¦ã€‚");
        break;
    }
    renderHUD();
  }

  // ============ ç®±å­ Modal ============

  const modalChest = document.getElementById("modal-chest");
  const chestGridEl = document.getElementById("chest-grid");
  const bpGridModalEl = document.getElementById("bp-grid-modal");

  function openChest() {
    renderChestModal();
    modalChest.classList.remove("hidden");
  }

  function closeChest() {
    modalChest.classList.add("hidden");
    renderAll();
  }

  document.getElementById("btn-chest-close").addEventListener("click", closeChest);
  modalChest.querySelector(".modal-backdrop").addEventListener("click", closeChest);

  function renderChestModal() {
    const chestSlots = gameState.inventory.chest;
    const bpSlots = gameState.inventory.backpack;

    chestGridEl.innerHTML = "";
    for (let i=0;i<chestSlots.length;i++) {
      const slot = chestSlots[i];
      const div = document.createElement("div");
      div.className = "inv-slot";
      if (!slot) {
        div.classList.add("inv-slot-empty");
      } else {
        const def = ITEM_DEFS[slot.type];
        div.textContent = def ? def.icon : "?";
        if (slot.count > 1) {
          const c = document.createElement("span");
          c.className = "inv-count";
          c.textContent = slot.count;
          div.appendChild(c);
        }
      }
      div.addEventListener("click", () => {
        if (!slot) return;
        const remain = addItemToSlots(gameState.inventory.backpack, slot.type, slot.count);
        if (remain === 0) {
          chestSlots[i] = null;
        } else {
          chestSlots[i].count = remain;
        }
        renderChestModal();
        renderHUD();
      });
      chestGridEl.appendChild(div);
    }

    bpGridModalEl.innerHTML = "";
    for (let i=0;i<bpSlots.length;i++) {
      const slot = bpSlots[i];
      const div = document.createElement("div");
      div.className = "inv-slot";
      if (!slot) {
        div.classList.add("inv-slot-empty");
      } else {
        const def = ITEM_DEFS[slot.type];
        div.textContent = def ? def.icon : "?";
        if (slot.count > 1) {
          const c = document.createElement("span");
          c.className = "inv-count";
          c.textContent = slot.count;
          div.appendChild(c);
        }
      }
      div.addEventListener("click", () => {
        if (!slot) return;
        const remain = addItemToSlots(gameState.inventory.chest, slot.type, slot.count);
        if (remain === 0) {
          bpSlots[i] = null;
        } else {
          bpSlots[i].count = remain;
        }
        renderChestModal();
        renderHUD();
      });
      bpGridModalEl.appendChild(div);
    }
  }

  // ============ Game Over / Demo End ============

  const modalGameover = document.getElementById("modal-gameover");
  document.getElementById("btn-restart-run").addEventListener("click", () => {
    modalGameover.classList.add("hidden");
    startNewRun();
  });
  modalGameover.querySelector(".modal-backdrop").addEventListener("click", () => {});

  const modalDemoEnd = document.getElementById("modal-demoend");
  document.getElementById("btn-demo-restart").addEventListener("click", () => {
    modalDemoEnd.classList.add("hidden");
    startNewRun();
  });
  modalDemoEnd.querySelector(".modal-backdrop").addEventListener("click", () => {});

  function showGameOver() {
    modalGameover.classList.remove("hidden");
  }
  function showDemoEnd() {
    modalDemoEnd.classList.remove("hidden");
  }

  // ============ æˆ˜æ–— / ä¼¤å®³ ============

  function eatBread() {
    if (!consumeItem("bread",1,false)) {
      pushLog("æ²¡æœ‰é¢åŒ…äº†ã€‚", true);
      renderHUD();
      return;
    }
    if (gameState.player.hp < gameState.player.maxHp) {
      gameState.player.hp += 1;
      pushLog("åƒæ‰ä¸€ä¸ªé¢åŒ…ï¼Œæ¢å¤ 1 ç‚¹ç”Ÿå‘½ã€‚");
    } else {
      gameState.player.tempHp += 1;
      pushLog("åƒæ‰ä¸€ä¸ªé¢åŒ…ï¼Œè·å¾— 1 ç‚¹ä¸´æ—¶ç”Ÿå‘½ã€‚");
    }
    renderAll();
  }

  function applyDamage(amount, ignoreArmor=false) {
    let dmg = amount;
    if (!ignoreArmor && gameState.player.armor > 0) {
      const used = Math.min(gameState.player.armor, dmg);
      gameState.player.armor -= used;
      dmg -= used;
    }
    if (dmg > 0) {
      if (gameState.player.tempHp > 0) {
        const used = Math.min(gameState.player.tempHp, dmg);
        gameState.player.tempHp -= used;
        dmg -= used;
      }
      if (dmg > 0) {
        gameState.player.hp -= dmg;
      }
    }

    if (gameState.player.hp <= 0) {
      pushLog("ä½ å€’åœ¨äº†åœ°åº•çš„é»‘æš—ä¸­â€¦â€¦", true);
      renderAll();
      showGameOver();
    } else {
      renderAll();
    }
  }

  function monsterAt(x,y) {
    return gameState.monsters.find(m=>m.alive && m.x===x && m.y===y);
  }

  function isWalkable(x,y,ignoreWalls=false) {
    const d = gameState.dungeon;
    if (!d) return false;
    if (x < 0 || x >= d.width || y < 0 || y >= d.height) return false;
    const t = d.tiles[y][x].type;
    if (ignoreWalls) return true;
    return (t === TILE_FLOOR || t === TILE_STAIR_UP || t === TILE_CHEST || t === TILE_HOLE);
  }

  // ============ ç©å®¶è¡ŒåŠ¨ï¼ˆçŸ¿æ´ï¼‰ ============

  function mineOrMove(dx, dy) {
    if (gameState.player.stunned > 0) {
      gameState.player.stunned -= 1;
      pushLog("ä½ è¢«ç²˜æ¶²æ€ªå®šèº«ï¼Œæ— æ³•è¡ŒåŠ¨è¿™ä¸€å›åˆã€‚");
      endPlayerTurn();
      return;
    }
    const d = gameState.dungeon;
    if (!d || !gameState.playerPos) return;

    const px = gameState.playerPos.x;
    const py = gameState.playerPos.y;
    const nx = px + dx;
    const ny = py + dy;
    gameState.player.facing = { dx, dy };

    if (nx < 0 || nx >= d.width || ny < 0 || ny >= d.height) {
      pushLog("å‰æ–¹æ˜¯åšç¡¬çš„å²©å£ã€‚");
      endPlayerTurn();
      return;
    }

    const tile = d.tiles[ny][nx];

    // 1. å¦‚æœæ˜¯å²©çŸ³ / çŸ¿çŸ³ => æŒ–æ˜é€»è¾‘ï¼ˆå¯èƒ½æŒ–å‡ºæ€ªç‰©ï¼‰
    if (tile.type === TILE_ROCK || tile.type === TILE_ORE) {
      if (gameState.player.pickaxe.durability <= 0) {
        pushLog("ç¨¿å­å·²ç»å®Œå…¨æŸåï¼Œæ— æ³•æŒ–æ˜ï¼", true);
        endPlayerTurn();
        return;
      }

      gameState.player.pickaxe.durability = Math.max(
        0,
        gameState.player.pickaxe.durability - 1
      );

      // æŒ–ä¹‹å‰å…ˆçœ‹çœ‹è¿™é‡Œæœ‰æ²¡æœ‰åŸ‹ç€çš„æ€ª
      const buriedMon = gameState.monsters.find(
        m => m.alive && m.buried && m.x === nx && m.y === ny
      );

      if (tile.type === TILE_ORE) {
        addItem("ore", 1, true);
        pushLog("æŒ–åˆ°äº†ä¸€å—çŸ¿çŸ³ã€‚");
      } else {
        pushLog("ä½ åœ¨å²©å£ä¸Šå‡¿å‡ºäº†ä¸€æ¡è£‚ç¼ã€‚");
      }

      // æŒ–æ‰çŸ³å¤´
      tile.type = TILE_FLOOR;

      if (buriedMon) {
        // åªæŒ–å¼€ï¼Œä¸å¾€å‰èµ°ï¼Œé¿å…å’Œæ€ªç‰©é‡å 
        buriedMon.buried = false;
        buriedMon.wakeDelay = 1;
        pushLog("ä½ æŒ–å¼€å²©çŸ³ï¼Œä¸€åªæ€ªç‰©éœ²å‡ºäº†èº«å½±â€¦â€¦", true);
      } else {
        // æ²¡æ€ªæ‰èµ°è¿›æ–°å¼€çš„é€šé“
        gameState.playerPos = { x: nx, y: ny };
      }

      updateVisibility();
      endPlayerTurn();
      return;
    }

    // 2. å¦åˆ™å…ˆçœ‹è¿™é‡Œæ˜¯å¦æœ‰æ€ª => æ”»å‡»
    const mon = monsterAt(nx, ny);
    if (mon && !mon.buried) {
      if (gameState.player.pickaxe.durability <= 0) {
        pushLog("ç¨¿å­å·²ç»å®Œå…¨æŸåï¼Œæ— æ³•æ”»å‡»ï¼", true);
        endPlayerTurn();
        return;
      }
      gameState.player.pickaxe.durability = Math.max(0, gameState.player.pickaxe.durability - 3);
      mon.alive = false;
      pushLog("ä½ æŒ¥åŠ¨ç¨¿å­ï¼Œå‡»ç¢äº†é¢å‰çš„æ€ªç‰©ã€‚");
      if (gameState.player.pickaxe.type === "magic" && gameState.rng() < 0.4) {
        addItem("ore", 1, true);
        pushLog("é­”æ³•æ®‹å…‰å‡ç»“æˆäº†ä¸€å—é¢å¤–çš„çŸ¿çŸ³ã€‚");
      }
      updateVisibility();
      endPlayerTurn();
      return;
    }

    // 3. æ²¡æœ‰æ€ª => å°è¯•ç§»åŠ¨
    if (isWalkable(nx, ny, false)) {
      gameState.playerPos = { x: nx, y: ny };
      if (tile.type === TILE_CHEST) {
        openDungeonChest();
      }
      if (tile.type === TILE_STAIR_UP) {
        pushLog("å›åˆ°å‡ºç”Ÿç‚¹ï¼ŒæŒ‰ E å¯ä»¥è¿”å›åŸºåœ°ã€‚");
      }
    } else {
      pushLog("è¿™é‡Œèµ°ä¸è¿‡å»ã€‚");
    }

    updateVisibility();
    endPlayerTurn();
  }


  function openDungeonChest() {
    const d = gameState.dungeon;
    const { x, y } = gameState.playerPos;
    const tile = d.tiles[y][x];
    if (tile.type !== TILE_CHEST) return;

    tile.type = TILE_FLOOR;

    pushLog("ä½ æ‰“å¼€äº†ä¸€ä¸ªå¤è€çš„æœ¨ç®±ã€‚", true);

    const rng = gameState.rng;
    const lootCount = randInt(rng, 1, 3);

    const lootTable = [
      { type:"bread", weight:25, min:1, max:1 },
      { type:"ore",   weight:20, min:2, max:5 },
      { type:"torch", weight:18, min:1, max:3 },
      { type:"bomb",  weight:16, min:1, max:2 },
      { type:"rope",  weight:10, min:1, max:1 }
    ];

    function weightedPick(table) {
      let total = 0;
      for (const e of table) total += e.weight;
      let r = rng() * total;
      for (const e of table) {
        if (r < e.weight) return e;
        r -= e.weight;
      }
      return table[table.length - 1];
    }

    // â˜… æ–°å¢ï¼šç»Ÿè®¡è¿™æ¬¡å®ç®±å®é™…å¼€å‡ºäº†ä»€ä¹ˆ
    const gained = {};

    for (let i = 0; i < lootCount; i++) {
      const entry = weightedPick(lootTable);
      const count = randInt(rng, entry.min, entry.max);
      addItem(entry.type, count, true);
      gained[entry.type] = (gained[entry.type] || 0) + count;
    }

    // â˜… æ–°å¢ï¼šç”Ÿæˆæç¤ºæ–‡æœ¬
    const parts = [];
    for (const [type, cnt] of Object.entries(gained)) {
      const def = ITEM_DEFS[type];
      const name = def ? def.name : type;
      parts.push(`${name}Ã—${cnt}`);
    }
    if (parts.length > 0) {
      pushLog(`ä½ ä»å®ç®±é‡Œæ‰¾åˆ°äº†ï¼š${parts.join("ï¼Œ")}ã€‚`, true);
    }
  }


  function endPlayerTurn() {
    if (!gameState.inDungeon) {
      renderAll();
      return;
    }

    // â˜… æ–°å¢ï¼šçŸ¿æ´å†…å›åˆè®¡æ•°
    if (gameState.dungeonTurn == null) gameState.dungeonTurn = 0;
    gameState.dungeonTurn += 1;

    // æ¶ˆè€— 1 å›åˆ
    gameState.turnsLeft -= 1;

    // å·²ä½¿ç”¨å›åˆæ•°ï¼ˆä»è¿™æ¬¡ä¸‹çŸ¿å¼€å§‹ç®—ï¼‰
    const turnsUsed = gameState.maxTurnsPerDay - gameState.turnsLeft;

    // === æç¯ 100 å›åˆåå˜æš—ï¼Œå¹¶åœ¨è§†é‡å¤–åˆ·æ€ª ===
    if (!gameState.lanternDimmed) {
      if (turnsUsed === 100) {
        gameState.lanternDimmed = true;
        gameState.lanternRadius = 2;
        // â˜… è®°å½•é»‘æš—å¼€å§‹çš„å›åˆæ•°
        gameState.darknessTurn = gameState.dungeonTurn;

        pushLog("æç¯çš„ç¯æ²¹å°†å°½ï¼Œä½ çš„è§†é‡éª¤ç„¶ç¼©å°ï¼Œé»‘æš—ä¸­æœ‰ä»€ä¹ˆå¼€å§‹è ¢è ¢æ¬²åŠ¨â€¦â€¦", true);

        updateVisibility();
        spawnMonstersOutsidePlayerVision();
      }
    } else {
      // â˜… å·²ç»é»‘æš—ï¼šæ¯ 10 å›åˆåˆ·æ–°ä¸€æ³¢æ€ªç‰©
      if (gameState.darknessTurn != null) {
        const sinceDark = gameState.dungeonTurn - gameState.darknessTurn;
        if (sinceDark > 0 && sinceDark % 20 === 0) {
          spawnMonstersOutsidePlayerVision();
        }
      }
    }

    // â˜… 150 å›åˆä¹‹åï¼šæ¯å›åˆè½çŸ³
    if (turnsUsed >= 150) {
      applyFallingRocks();
    }

    // å›åˆç”¨å®Œï¼šå¼ºåˆ¶æ’¤é€€
    if (gameState.turnsLeft <= 0) {
      gameState.turnsLeft = 0;
      pushLog("çŸ¿æ´åå¡Œï¼Œä½ å¹¸è¿çš„æ‰¾åˆ°è·¯æ’¤å›äº†åŸºåœ°ã€‚", true);
      returnToBaseFromDungeon();
      return;
    }

    updateMonsters();
    updateBombs();
    updateVisibility();
    renderAll();
  }

  function updateBombs() {
    const d = gameState.dungeon;
    if (!d) return;
    const newBombs = [];
    for (const b of gameState.bombs) {
      b.timer -= 1;
      if (b.timer <= 0) {
        pushLog("ç‚¸è¯åŒ…ç‚¸å“äº†ï¼", true);
        for (let dy=-1; dy<=1; dy++) {
          for (let dx=-1; dx<=1; dx++) {
            const x = b.x + dx;
            const y = b.y + dy;
            if (x<0 || x>=d.width || y<0 || y>=d.height) continue;
            const tile = d.tiles[y][x];
            if (tile.type === TILE_ROCK || tile.type === TILE_ORE || tile.type === TILE_HOLE) {
              if (tile.type === TILE_ORE) {
                if (gameState.rng() < 0.5) {
                  addItem("ore",1,true);
                }
              }
              tile.type = TILE_FLOOR;
            }
            const mon = monsterAt(x,y);
            if (mon) mon.alive = false;
            if (gameState.playerPos && gameState.playerPos.x === x && gameState.playerPos.y === y) {
              applyDamage(2,false);
            }
          }
        }
      } else {
        newBombs.push(b);
      }
    }
    gameState.bombs = newBombs;
  }

  // â˜… æ–°å¢ï¼šè½çŸ³é€»è¾‘â€”â€”éšæœºæŠŠ 1~3 ä¸ªéå²©çŸ³æ ¼å­å˜æˆå²©çŸ³
  function applyFallingRocks() {
    const d = gameState.dungeon;
    if (!d || !gameState.rng) return;

    const num = randInt(gameState.rng, 1, 3);
    let placed = 0;
    let guard = 0;

    const spawn = gameState.dungeonSpawn;

    while (placed < num && guard < 500) {
      guard++;
      const x = randInt(gameState.rng, 0, d.width - 1);
      const y = randInt(gameState.rng, 0, d.height - 1);
      const tile = d.tiles[y][x];

      // å·²ç»æ˜¯å²©çŸ³å°±è·³è¿‡
      if (tile.type === TILE_ROCK) continue;

      // ä¸ç ¸å‡ºç”Ÿç‚¹
      if (spawn && x === spawn.x && y === spawn.y) continue;

      // ä¸ç ¸ç©å®¶è„šä¸‹ï¼ˆé¿å…ç›´æ¥æŠŠäººå°ä½ / å¡æ­»ï¼‰
      if (gameState.playerPos &&
          gameState.playerPos.x === x &&
          gameState.playerPos.y === y) {
        continue;
      }

      // ç ¸æ‰è¿™é‡Œçš„ç‚¸è¯åŒ…
      gameState.bombs = gameState.bombs.filter(b => !(b.x === x && b.y === y));

      // å¦‚æœæœ‰æ€ªï¼šéå¹½çµè§†ä¸ºè¢«åŸ‹å…¥å²©çŸ³
      const mon = monsterAt(x, y);
      if (mon && mon.type !== MON_GHOST) {
        mon.buried = true;
        mon.wakeDelay = 0;
      }

      tile.type = TILE_ROCK;
      placed++;
    }

    if (placed > 0) {
      pushLog(`æ´é¡¶è½ä¸‹ç¢çŸ³ï¼Œå°ä½äº† ${placed} å¤„é€šè·¯ã€‚`, true);
    }
  }


    // æç¯å˜æš—æ—¶ï¼šåœ¨ç©å®¶å½“å‰è§†é‡å¤–éšæœºåˆ·ä¸€æ³¢æ€ª
  function spawnMonstersOutsidePlayerVision() {
    const d = gameState.dungeon;
    if (!d || !gameState.playerPos || !gameState.rng) return;

    const px = gameState.playerPos.x;
    const py = gameState.playerPos.y;
    const candidates = [];

    for (let y = 0; y < d.height; y++) {
      for (let x = 0; x < d.width; x++) {
        const tile = d.tiles[y][x];

        // å¿…é¡»åœ¨å½“å‰è§†é‡å¤–
        if (tile.visible) continue;

        // åªèƒ½åœ¨å¯ç«™ç«‹/æ½œä¼çš„åœ°å½¢åˆ·
        if (!(tile.type === TILE_FLOOR ||
              tile.type === TILE_HOLE  ||
              tile.type === TILE_ROCK)) continue;

        // å·²æœ‰æ€ªå°±ä¸å†åˆ·
        if (monsterAt(x, y)) continue;

        // ç¦»ç©å®¶ç¨å¾®è¿œä¸€ç‚¹ï¼Œè‡³å°‘æ¯”è§†é‡å†è¿œ 1 æ ¼
        const cheb = Math.max(Math.abs(x - px), Math.abs(y - py));
        if (cheb <= (gameState.lanternRadius || PLAYER_LIGHT_RADIUS) + 1) continue;

        candidates.push({ x, y });
      }
    }

    if (!candidates.length) return;

    const rng = gameState.rng;
    shuffle(rng, candidates);
    const spawnCount = randInt(rng, 2, 4);  // ä¸€æ¬¡åˆ· 3~6 åª

    for (let i = 0; i < spawnCount && i < candidates.length; i++) {
      const pos = candidates[i];
      const roll = rng();

      // ç®€å•åˆ†é…ï¼šåƒµå°¸æœ€å¤šï¼Œå…¶æ¬¡ç²˜æ¶²æ€ªï¼Œå¶å°”åˆ·å¹½çµ
      let type;
      if (roll < 0.6) type = MON_ZOMBIE;
      else if (roll < 0.9) type = MON_SLIME;
      else type = MON_GHOST;

      const tileType = d.tiles[pos.y][pos.x].type;
      const buried = (tileType === TILE_ROCK && type !== MON_GHOST);

      const mon = {
        id: gameState.nextMonsterId++,
        type,
        x: pos.x,
        y: pos.y,
        alive: true,
        buried,
        wakeDelay: buried ? 1 : 0,
        homeX: pos.x,
        homeY: pos.y,
        roamRadius: type === MON_GHOST ? 2 : 0,
        attackCooldown: (type === MON_SLIME || type === MON_GHOST)
          ? randInt(rng, 0, 3)
          : 0,
        charging: false,
        attackType: null,
        chargePath: null,
        chargeDir: null,
        chargeTarget: null
      };

      gameState.monsters.push(mon);
    }

    pushLog("é»‘æš—æ·±å¤„å“èµ·äº†æ–°çš„æ€ªç‰©å£°å“â€¦â€¦", true);
  }


  function updateMonsters() {
    if (!gameState.playerPos || !gameState.dungeon) return;
    const d = gameState.dungeon;

    gameState.ghostTelegraphs = [];
    gameState.slimeTelegraphs = [];

    const px = gameState.playerPos.x;
    const py = gameState.playerPos.y;

    // æ¯å›åˆéƒ½å…ˆæ¸…ç©ºé¢„è­¦è·¯å¾„


    let anyMoved = false;

    function manhattan(x1, y1, x2, y2) {
      return Math.abs(x1 - x2) + Math.abs(y1 - y2);
    }

    for (const m of gameState.monsters) {
      if (!m.alive) continue;

      m.justMoved = false;

      const tileHere = d.tiles[m.y][m.x];

      // éå¹½çµï¼šåœ¨å²©çŸ³ä¸­å°±æ˜¯åŸ‹ç€
      if (m.type !== MON_GHOST && tileHere.type === TILE_ROCK) {
        m.buried = true;
      }
      if (m.buried && tileHere.type !== TILE_ROCK) {
        m.buried = false;
        m.wakeDelay = Math.max(m.wakeDelay || 0, 1);
      }
      if (m.buried) continue;

      if (m.wakeDelay && m.wakeDelay > 0) {
        m.wakeDelay -= 1;
        continue;
      }

      const dist = manhattan(m.x, m.y, px, py);

      // å·²åœ¨è“„åŠ›çŠ¶æ€ï¼šä¼˜å…ˆæ‰§è¡Œæ”»å‡»åŠ¨ä½œ
      if (m.charging && m.attackType === "dash" && m.type === MON_GHOST) {
        const oldX = m.x, oldY = m.y;
        performGhostDash(m);
        if (m.x !== oldX || m.y !== oldY) {
          m.justMoved = true;
          anyMoved = true;
        }
        continue;
      }
      if (m.charging && m.attackType === "jump" && m.type === MON_SLIME) {
        const oldX = m.x, oldY = m.y;
        performSlimeJump(m);
        if (m.x !== oldX || m.y !== oldY) {
          m.justMoved = true;
          anyMoved = true;
        }
        continue;
      }

      // === åƒµå°¸é€»è¾‘ ===
      if (m.type === MON_ZOMBIE) {
        if (dist === 1) {
          monsterAttack(m, false);
          continue;
        }

        let aggro = false;
        if (dist <= PLAYER_LIGHT_RADIUS &&
            hasLineOfSight(m.x, m.y, px, py, false)) {
          aggro = true;
        }

        const oldX = m.x, oldY = m.y;

        if (aggro) {
          moveMonsterTowardsPlayer(m, 1, false, false);
        } else {
          const here = d.tiles[m.y][m.x];
          const wanderProb = (here.type === TILE_HOLE ? 0.7 : 0.25);
          if (gameState.rng() < wanderProb) {
            randomMonsterStep(m, false, false);
          }
        }

        if (m.x !== oldX || m.y !== oldY) {
          m.justMoved = true;
          anyMoved = true;
        }
        continue;
      }

      // === ç²˜æ¶²æ€ªé€»è¾‘ ===
      if (m.type === MON_SLIME) {
        // è·ç¦» 1 ä¸”ç©å®¶æ— æŠ¤ç”²ï¼šè¿‘æˆ˜æŠ±è„¸ï¼ˆå®šèº«ï¼‰
        if (dist === 1 &&
            gameState.player.armor <= 0 &&
            m.attackCooldown <= 0) {
          monsterAttack(m, false);  // é‡Œé¢æ˜¯å®šèº« + ç²˜æ¶²æ€ªè‡ªæ€
          m.attackCooldown = 2;
          continue;
        }

        // â˜… æ”»å‡» CD æœŸé—´ï¼šåªæ¸¸è¡ï¼Œä¸å†åˆ»æ„å‡‘ 3 æ ¼
        if (m.attackCooldown > 0) {
          const oldX = m.x, oldY = m.y;
          randomMonsterStep(m, false, false);
          if (m.x !== oldX || m.y !== oldY) {
            m.justMoved = true;
            anyMoved = true;
          }
          m.attackCooldown -= 1;
          continue;
        }

        // ===== ä»¥ä¸‹ï¼šattackCooldown === 0 æ—¶çš„æ­£å¸¸â€œçŒæ€é€»è¾‘â€ =====

        // 1ï¼‰å¦‚æœä¸€å¼€å§‹å°±å·²ç»æ˜¯ 3 æ ¼ç›´çº¿ï¼Œç›´æ¥é¢„è­¦
        const sameCol0 = (m.x === px && Math.abs(m.y - py) === 3);
        const sameRow0 = (m.y === py && Math.abs(m.x - px) === 3);
        if (sameCol0 || sameRow0) {
          startSlimeCharge(m);
          continue;
        }

        // 2ï¼‰å¦åˆ™ï¼šå°è¯•ç§»åŠ¨åˆ°â€œè·ç¦»ç©å®¶çº¦ 3 æ ¼ï¼Œæœ€å¥½åŒä¸€è¡Œ/åˆ—â€çš„ä½ç½®
        const dirs = [
          {dx: 1, dy: 0}, {dx: -1, dy: 0},
          {dx: 0, dy: 1}, {dx: 0, dy: -1},
          {dx: 0, dy: 0}  // å¯ä»¥é€‰æ‹©ä¸åŠ¨
        ];

        let bestX = m.x;
        let bestY = m.y;
        let bestScore = Infinity;

        for (const dir of dirs) {
          const nx = m.x + dir.dx;
          const ny = m.y + dir.dy;

          // ä¸ä¸»åŠ¨èµ°è¿›ç©å®¶æ‰€åœ¨æ ¼
          if (nx === px && ny === py) continue;

          if (!canMonsterMoveTo(m, nx, ny, false, false)) continue;
          if (monsterAt(nx, ny) && !(nx === m.x && ny === m.y)) continue;

          const distNew = manhattan(nx, ny, px, py);
          let score = Math.abs(distNew - 3);
          // æ›´å€¾å‘äºåŒä¸€è¡Œ/åˆ—
          if (!(nx === px || ny === py)) score += 1;

          if (score < bestScore) {
            bestScore = score;
            bestX = nx;
            bestY = ny;
          }
        }

        const oldX = m.x, oldY = m.y;
        if (bestX !== m.x || bestY !== m.y) {
          m.x = bestX;
          m.y = bestY;
          m.justMoved = true;
          anyMoved = true;
        }

        // â˜… 3ï¼‰ç§»åŠ¨ä¹‹åï¼Œå†æ£€æŸ¥ä¸€æ¬¡ï¼šå¦‚æœç°åœ¨åˆšå¥½è·ç¦» 3 ä¸”åŒä¸€è¡Œ/åˆ—ï¼Œå°±ç«‹åˆ»é¢„è­¦
        const newDist = manhattan(m.x, m.y, px, py);
        if (newDist === 3 && (m.x === px || m.y === py) && m.attackCooldown <= 0) {
          startSlimeCharge(m);
          continue;
        }

        // è¿™é‡Œ CD è¿˜æ˜¯ 0ï¼Œä¸ç”¨å‡
        continue;
      }

      // === å¹½çµé€»è¾‘ ===
      if (m.type === MON_GHOST) {
        // ç©å®¶è¿›å…¥ 3 æ ¼èŒƒå›´ & å†·å´å¥½ï¼šé¢„è­¦å†²åˆºï¼ˆæœ‰æŠ¤ç¬¦ä¸”è·ç¦»>1 æ—¶ä¸å†²ï¼‰
        if (dist <= 3 && m.attackCooldown <= 0) {
          if (gameState.player.charmCharges > 0 && dist > 1) {
            // æœ‰æŠ¤ç¬¦ï¼Œå¹½çµä¼šç›¯ç€ä½ ä½†ä¸å†²åˆº
          } else {
            startGhostCharge(m);
            continue;
          }
        }
        let aggro = (dist <= 3);
        if (gameState.player.charmCharges > 0 && dist > 1 && dist <= 3) {
          aggro = false;
        }
        if (m.attackCooldown > 0) {
          aggro = false;
        }

        const oldX = m.x, oldY = m.y;

        if (aggro) {
          // å¹½çµå¯ä»¥æ— è§†å²©çŸ³ï¼Œä½†æ´»åŠ¨èŒƒå›´é™åˆ¶åœ¨å°åœˆé‡Œ
          moveMonsterTowardsPlayer(m, 1, true, true);
        } else {
          randomMonsterStep(m, true, true);
        }

        if (m.x !== oldX || m.y !== oldY) {
          m.justMoved = true;
          anyMoved = true;
        }

        if (m.attackCooldown > 0) m.attackCooldown -= 1;
        continue;
      }

    }

    // æœ‰æ€ªç‰©ç§»åŠ¨æ—¶ï¼š1 ç§’åæ¸…æ‰ 'justMoved' å¹¶åˆ·æ–° dungeonï¼ˆè®©åŠ¨ç”»ç»“æŸï¼‰
    if (anyMoved) {
      if (gameState.monsterMoveAnimTimer) {
        clearTimeout(gameState.monsterMoveAnimTimer);
      }
      gameState.monsterMoveAnimTimer = setTimeout(() => {
        gameState.monsters.forEach(mm => {
          if (mm.alive) mm.justMoved = false;
        });
        gameState.monsterMoveAnimTimer = null;
        if (gameState.mode === GameMode.DUNGEON) {
          renderDungeon();
        }
      }, 1000);
    }
  }

  function startGhostCharge(m) {
    if (!gameState.playerPos || !gameState.dungeon) return;
    const px = gameState.playerPos.x;
    const py = gameState.playerPos.y;

    let dx = px - m.x;
    let dy = py - m.y;
    let dir = { dx: 0, dy: 0 };

    // é€‰æ‹©ä¸»æ–¹å‘ï¼ˆåªç›´çº¿å†²åˆºï¼Œä¸èµ°æ–œçº¿ï¼‰
    if (Math.abs(dx) >= Math.abs(dy) && dx !== 0) {
      dir.dx = dx > 0 ? 1 : -1;
    } else if (dy !== 0) {
      dir.dy = dy > 0 ? 1 : -1;
    } else {
      return;
    }

    const d = gameState.dungeon;
    const path = [];
    let cx = m.x;
    let cy = m.y;

    // æœ€å¤šé¢„è­¦ 3 æ ¼ï¼Œç›´åˆ°åœ°å›¾è¾¹ç¼˜æˆ–ç©å®¶
    for (let i = 0; i < 4; i++) {
      const nx = cx + dir.dx;
      const ny = cy + dir.dy;
      if (nx < 0 || nx >= d.width || ny < 0 || ny >= d.height) break;
      path.push({ x: nx, y: ny });
      cx = nx;
      cy = ny;
    }

    if (path.length === 0) return;

    m.charging = true;
    m.attackType = "dash";
    m.chargePath = path;
    m.chargeDir = dir;
    gameState.ghostTelegraphs.push(...path);

    pushLog("å¹½çµå‘å‡ºåˆºè€³çš„ä½é¸£ï¼Œå‰æ–¹æ³›èµ·è¡€çº¢çš„å…‰èŠ’â€¦â€¦", true);
  }

  function performGhostDash(m) {
    const d = gameState.dungeon;
    if (!d || !m.chargePath || !m.chargePath.length) {
      m.charging = false;
      m.attackType = null;
      return;
    }
    gameState.ghostTelegraphs = [];
    let lastPos = { x: m.x, y: m.y };
    const dir = m.chargeDir || { dx: 0, dy: 0 };

    for (const step of m.chargePath) {
      const nx = step.x;
      const ny = step.y;
      if (nx < 0 || nx >= d.width || ny < 0 || ny >= d.height) break;

      lastPos = { x: nx, y: ny };

      // å†²åˆºè·¯å¾„ä¸Šç»è¿‡ç©å®¶å°±ä¼¤å®³
      if (gameState.playerPos &&
          gameState.playerPos.x === nx &&
          gameState.playerPos.y === ny) {

        if (gameState.player.charmCharges > 0) {
          gameState.player.charmCharges = 0;
          pushLog("å¹½çµå†²åˆºæ—¶ï¼Œä½ çš„æŠ¤ç¬¦å•ªåœ°ä¸€å£°ç¢è£‚ï¼", true);
        }
        pushLog("å¹½çµçš„å†²åˆºç©¿è¿‡äº†ä½ çš„èº«ä½“ã€‚", true);
        applyDamage(1, true); // æ— è§†æŠ¤ç”²
      }
    }

    const oldX = m.x;
    const oldY = m.y;

    m.x = lastPos.x;
    m.y = lastPos.y;

    // è‹¥æœ€ç»ˆåœåœ¨ç©å®¶æ ¼å­ä¸Šï¼Œå°è¯•å†å¾€å‰æŒªä¸€æ ¼ç¦»å¼€
    if (gameState.playerPos &&
        gameState.playerPos.x === m.x &&
        gameState.playerPos.y === m.y &&
        dir && (dir.dx !== 0 || dir.dy !== 0)) {
      const ex = m.x + dir.dx;
      const ey = m.y + dir.dy;
      if (ex >= 0 && ex < d.width && ey >= 0 && ey < d.height) {
        m.x = ex;
        m.y = ey;
      }
    }

    m.charging = false;
    m.attackType = null;
    m.chargePath = null;
    m.chargeDir = null;
    m.attackCooldown = 3;
  }



  function startSlimeCharge(m) {
    if (!gameState.playerPos || !gameState.dungeon) return;
    const px = gameState.playerPos.x;
    const py = gameState.playerPos.y;
    let dx = px - m.x;
    let dy = py - m.y;
    let dir = { dx: 0, dy: 0 };

    // åªå…è®¸ç›´çº¿è·³ï¼ˆåŒä¸€è¡Œæˆ–åŒä¸€åˆ—ï¼‰
    if (dx === 0) {
      dir.dy = dy > 0 ? 1 : -1;
    } else if (dy === 0) {
      dir.dx = dx > 0 ? 1 : -1;
    } else {
      return;
    }

    const d = gameState.dungeon;
    // é¢„è­¦æ ¼ï¼šç¦»ç²˜æ¶²æ€ª 2 æ ¼çš„ä½ç½®ï¼ˆä¸­é—´é‚£æ ¼ï¼‰
    const target = { x: m.x + dir.dx * 2, y: m.y + dir.dy * 2 };
    if (target.x < 0 || target.x >= d.width || target.y < 0 || target.y >= d.height) return;

    m.charging = true;
    m.attackType = "jump";
    m.chargeTarget = target;

    gameState.slimeTelegraphs.push(target);
    pushLog("ç²˜æ¶²æ€ªå¼€å§‹é¼“èƒ€ï¼Œå‰æ–¹çš„åœ°é¢æ³›èµ·è¯¡å¼‚çš„è“å…‰â€¦â€¦", true);
  }


  function performSlimeJump(m) {
    const d = gameState.dungeon;
    if (!d || !m.chargeTarget) {
      m.charging = false;
      m.attackType = null;
      return;
    }
    gameState.slimeTelegraphs = [];
    const tx = m.chargeTarget.x;
    const ty = m.chargeTarget.y;

    // è·³è·ƒæ–¹å‘
    const dir = {
      dx: Math.sign(tx - m.x),
      dy: Math.sign(ty - m.y)
    };

    let landingX = tx;
    let landingY = ty;

    // ç›®æ ‡æ ¼èµ°ä¸è¿‡å»ï¼Œè¿™æ¬¡è·³è·ƒä½œåºŸ
    if (!canMonsterMoveTo(m, landingX, landingY, false, false)) {
      m.charging = false;
      m.attackType = null;
      m.chargeTarget = null;
      m.attackCooldown = 2;
      return;
    }

    let hit = false;

    if (gameState.playerPos &&
        gameState.playerPos.x === landingX &&
        gameState.playerPos.y === landingY) {

      // åªæ‰“æŠ¤ç”²
      if (gameState.player.armor > 0) {
        gameState.player.armor -= 1;
        pushLog("ç²˜æ¶²æ€ªè·¨æ ¼æ‰‘å‡»ï¼Œæ’ç¢äº†ä½ çš„ä¸€ç‚¹æŠ¤ç”²ï¼", true);
      } else {
        pushLog("ç²˜æ¶²æ€ªæ‰‘åˆ°ä½ è„šè¾¹ï¼Œä½†ä½ èº«ä¸Šå·²ç»æ²¡æœ‰æŠ¤ç”²äº†ã€‚", true);
      }
      hit = true;
    }

    if (hit) {
      // å‘½ä¸­æ—¶ï¼šæœ€åç¼©å›åˆ°ç¦»ç©å®¶ 1 æ ¼çš„ä½ç½®
      const bx = landingX - dir.dx;
      const by = landingY - dir.dy;
      if (canMonsterMoveTo(m, bx, by, false, false) && !monsterAt(bx, by)) {
        m.x = bx;
        m.y = by;
      } else {
        m.x = landingX;
        m.y = landingY;
      }
    } else {
      // æ²¡å‘½ä¸­ï¼šå°±è·³åˆ°é¢„è­¦æ ¼
      m.x = landingX;
      m.y = landingY;
    }

    m.charging = false;
    m.attackType = null;
    m.chargeTarget = null;
    m.attackCooldown = 2;
  }




  function isWithinHome(m, x, y) {
    if (!m.roamRadius || typeof m.homeX !== "number") return true;
    return (Math.abs(x - m.homeX) <= m.roamRadius &&
            Math.abs(y - m.homeY) <= m.roamRadius);
  }

  function canMonsterMoveTo(m, x, y, ignoreWalls, restrictHome) {
    const d = gameState.dungeon;
    if (!d) return false;
    if (x < 0 || x >= d.width || y < 0 || y >= d.height) return false;
    if (restrictHome && !isWithinHome(m, x, y)) return false;
    if (ignoreWalls) return true;
    const t = d.tiles[y][x].type;
    return (t === TILE_FLOOR || t === TILE_HOLE || t === TILE_STAIR_UP || t === TILE_CHEST);
  }

  function randomMonsterStep(m, ignoreWalls, restrictHome) {
    const d = gameState.dungeon;
    if (!d) return;
    const dirs = [
      { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
      { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
    ];
    shuffle(gameState.rng, dirs);
    for (const dir of dirs) {
      const nx = m.x + dir.dx;
      const ny = m.y + dir.dy;
      if (!canMonsterMoveTo(m, nx, ny, ignoreWalls, restrictHome)) continue;
      if (monsterAt(nx, ny)) continue;
      m.x = nx;
      m.y = ny;
      break;
    }
  }

  function moveMonsterTowardsPlayer(m, stepCount, ignoreWalls, restrictHome) {
    if (!gameState.playerPos || !gameState.dungeon) return;
    const px = gameState.playerPos.x;
    const py = gameState.playerPos.y;

    for (let step = 0; step < stepCount; step++) {
      let dx = px - m.x;
      let dy = py - m.y;
      if (dx === 0 && dy === 0) return;
      const ax = Math.abs(dx), ay = Math.abs(dy);

      const dirs = [];
      if (ax >= ay && dx !== 0) {
        dirs.push({ dx: Math.sign(dx), dy: 0 });
        if (dy !== 0) dirs.push({ dx: 0, dy: Math.sign(dy) });
      } else if (ay > ax && dy !== 0) {
        dirs.push({ dx: 0, dy: Math.sign(dy) });
        if (dx !== 0) dirs.push({ dx: Math.sign(dx), dy: 0 });
      } else {
        dirs.push(
          { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
          { dx: 0, dy: 1 }, { dx: 0, dy: -1 }
        );
      }

      let moved = false;
      for (const dir of dirs) {
        const nx = m.x + dir.dx;
        const ny = m.y + dir.dy;
        if (!canMonsterMoveTo(m, nx, ny, ignoreWalls, restrictHome)) continue;
        if (monsterAt(nx, ny)) continue;
        m.x = nx;
        m.y = ny;
        moved = true;
        break;
      }
      if (!moved) return;
    }
  }


  function monsterAttack(m, ghostIgnoreArmor = false) {
    if (m.type === MON_ZOMBIE) {
      // å°–åˆºç›¾ç‰Œä¼˜å…ˆ
      if (gameState.player.shieldCharges > 0) {
        gameState.player.shieldCharges -= 1;
        m.alive = false;
        pushLog("å°–åˆºç›¾ç‰Œå‘åŠ›ï¼Œåƒµå°¸è¢«åå‡»å‡»ç¢ï¼", true);
        return;
      }
      pushLog("åƒµå°¸å’¬äº†ä½ ä¸€å£ã€‚", true);
      applyDamage(1, false);

    } else if (m.type === MON_SLIME) {
      // è¿™é‡Œåªç”¨äºè¿‘æˆ˜æƒ…å†µï¼šåªåœ¨â€œç©å®¶æ²¡æœ‰æŠ¤ç”²â€æ—¶è¢«è°ƒç”¨ï¼ˆç”± updateMonsters æ§åˆ¶ï¼‰
      if (gameState.player.shieldCharges > 0) {
        gameState.player.shieldCharges -= 1;
        m.alive = false;
        pushLog("å°–åˆºç›¾ç‰Œåå‡»ï¼Œå°†ç²˜æ¶²æ€ªæˆ³æˆä¸€æ»©ã€‚", true);
        return;
      }
      // çº¯æ§åˆ¶ï¼šå®šèº«ä¸€å›åˆï¼Œä¸æ‰è¡€
      pushLog("ç²˜æ¶²æ€ªé™„ç€åœ¨ä½ èº«ä¸Šï¼Œä½ è¢«å®šä½ä¸€å›åˆã€‚", true);
      gameState.player.stunned = 1;
      m.alive = false;

    } else if (m.type === MON_GHOST) {
      // ç›®å‰å¹½çµçš„çœŸæ­£ä¼¤å®³æ¥è‡ªå†²åˆºï¼ˆperformGhostDashï¼‰ï¼Œè¿™é‡ŒåŸºæœ¬ä¸ä¼šè¢«ç”¨åˆ°
      if (gameState.player.charmCharges > 0) {
        gameState.player.charmCharges = 0;
        pushLog("å¹½çµè´´è¿‘æ—¶ï¼Œä½ çš„æŠ¤ç¬¦ç¢è£‚äº†ã€‚", true);
      }
      pushLog("å¹½çµçš„çˆªå­æ è¿‡ä½ çš„å¿ƒè„ã€‚", true);
      applyDamage(1, true);
    }
  }


  // ============ ç«æŠŠ / ç‚¸è¯ / ç»³ç´¢ ============

  function placeTorch() {
    if (!gameState.inDungeon) {
      pushLog("åªæœ‰åœ¨çŸ¿æ´é‡Œæ‰èƒ½æ’ç«æŠŠã€‚");
      return;
    }
    if (!consumeItem("torch",1,true)) {
      pushLog("ä½ æ²¡æœ‰ç«æŠŠã€‚", true);
      renderHUD();
      return;
    }
    const d = gameState.dungeon;
    if (!d || !gameState.playerPos) return;
    const t = d.tiles[gameState.playerPos.y][gameState.playerPos.x];
    t.hasTorch = true;
    pushLog("ä½ åœ¨è„šè¾¹æ’ä¸‹ä¸€æ”¯ç«æŠŠã€‚");
    updateVisibility();
    endPlayerTurn();
  }

  function placeBomb() {
    if (!gameState.inDungeon) {
      pushLog("åªæœ‰åœ¨çŸ¿æ´é‡Œæ‰èƒ½æ”¾ç½®ç‚¸è¯åŒ…ã€‚");
      return;
    }
    if (!consumeItem("bomb",1,true)) {
      pushLog("ä½ æ²¡æœ‰ç‚¸è¯åŒ…ã€‚", true);
      renderHUD();
      return;
    }
    if (!gameState.playerPos) return;
    gameState.bombs.push({x:gameState.playerPos.x, y:gameState.playerPos.y, timer:3});
    pushLog("ä½ æ”¾ä¸‹äº†ä¸€ä¸ªç‚¸è¯åŒ…ï¼Œä¸‰å›åˆåä¼šçˆ†ç‚¸ã€‚");
    endPlayerTurn();
  }

  function useRope() {
    if (!gameState.inDungeon) {
      pushLog("ç»³ç´¢åªèƒ½åœ¨çŸ¿æ´é‡Œä½¿ç”¨ã€‚");
      return;
    }
    const d = gameState.dungeon;
    if (!d || !gameState.playerPos) return;

    if (!gameState.ropeAnchor) {
      // è®¾ç½®é”šç‚¹
      if (!consumeItem("rope",1,true)) {
        pushLog("ä½ æ²¡æœ‰ç»³ç´¢ã€‚", true);
        renderHUD();
        return;
      }
      gameState.ropeAnchor = {x:gameState.playerPos.x, y:gameState.playerPos.y};
      pushLog("ä½ åœ¨è¿™é‡Œè®¾ç½®äº†ä¸€ä¸ªç»³ç´¢é”šç‚¹ã€‚");
      endPlayerTurn();
    } else {
      // å›åˆ°é”šç‚¹
      gameState.playerPos = {...gameState.ropeAnchor};
      gameState.ropeAnchor = null;
      pushLog("ä½ æ²¿ç€ç»³ç´¢å›åˆ°äº†é”šç‚¹ä½ç½®ã€‚");
      updateVisibility();
      endPlayerTurn();
    }
  }

  // ============ è§†å›¾åˆ‡æ¢ & è¿›å…¥çŸ¿æ´ / è¿”å›åŸºåœ° ============

  function enterDungeon() {
    if (gameState.hasEnteredDungeonThisDay) {
      pushLog("ä»Šå¤©ä½ å·²ç»ä¸‹è¿‡çŸ¿æ´äº†ï¼Œå¤ªç–²æƒ«ï¼Œè¿˜æ˜¯å›å»ä¼‘æ¯å§ã€‚", true);
      return;
    }
    gameState.hasEnteredDungeonThisDay = true;
    generateDungeon();
    gameState.inDungeon = true;
    gameState.mode = GameMode.DUNGEON;
    gameState.playerPos = {...gameState.dungeonSpawn};
    gameState.turnsLeft = gameState.maxTurnsPerDay;
    gameState.player.stunned = 0;
    // æ¯æ¬¡ä¸‹çŸ¿éƒ½æ‹¿ç€æç¯ï¼Œåˆå§‹è§†é‡å’Œç°åœ¨ä¸€æ ·
    gameState.lanternRadius = PLAYER_LIGHT_RADIUS;
    gameState.lanternDimmed = false;
    // â˜… æ–°å¢
    gameState.dungeonTurn = 0;
    gameState.darknessTurn = null;

    pushLog("ä½ èµ°ä¸‹äº†é€šå¾€æ›´æ·±å¤„çš„é€šé“ï¼Œæç¯ç…§äº®äº†å‰æ–¹ã€‚");
    pushLog("æ¯ä¸€æ¬¡è¡ŒåŠ¨éƒ½ä¼šæ¶ˆè€— 1 å›åˆï¼Œ100 å›åˆåæç¯ä¼šå˜æš—ã€‚");
    updateVisibility();
    renderAll();
  }

  function returnToBaseFromDungeon() {
    gameState.mode = GameMode.BASE;
    gameState.inDungeon = false;
    gameState.turnsLeft = -1;
    gameState.playerPos = null;
    gameState.bombs = [];
    gameState.ropeAnchor = null;
    gameState.player.tempHp = 0;
    pushLog("ä½ å›åˆ°äº†ä¸´æ—¶åŸºåœ°ã€‚");
    renderAll();
  }

  // ============ è¾“å…¥å¤„ç† ============

  document.addEventListener("keydown", (e) => {
    if (!modalGameover.classList.contains("hidden") ||
        !modalDemoEnd.classList.contains("hidden") ||
        !modalMerchant.classList.contains("hidden") ||
        !modalChest.classList.contains("hidden")) {
      return;
    }

    const key = e.key;

    if (key === "b" || key === "B") {
      eatBread();
      return;
    }
    if (key === "t" || key === "T") {
      placeTorch();
      return;
    }
    if (key === "f" || key === "F") {
      placeBomb();
      return;
    }
    if (key === "r" || key === "R") {
      useRope();
      return;
    }

    if (gameState.mode === GameMode.BASE) {
      handleBaseKey(e);
    } else if (gameState.mode === GameMode.DUNGEON) {
      handleDungeonKey(e);
    }
  });

  function handleBaseKey(e) {
    const key = e.key;
    let dx = 0, dy = 0;
    if (key === "ArrowUp" || key === "w" || key === "W") dy = -1;
    else if (key === "ArrowDown" || key === "s" || key === "S") dy = 1;
    else if (key === "ArrowLeft" || key === "a" || key === "A") dx = -1;
    else if (key === "ArrowRight" || key === "d" || key === "D") dx = 1;

    if (dx !==0 || dy !==0) {
      const nx = clamp(gameState.base.player.x + dx,0,gameState.base.width-1);
      const ny = clamp(gameState.base.player.y + dy,0,gameState.base.height-1);
      gameState.base.player = {x:nx,y:ny};
      renderBase();
      return;
    }

    if (key === " " || key === "Enter" || key === "e" || key === "E") {
      const x = gameState.base.player.x;
      const y = gameState.base.player.y;

      // åºŠï¼šç»“æŸå½“å¤©
      if (x === 2 && y === 1) {
        pushLog("ä½ èººä¸ŠåºŠï¼Œç»“æŸè¿™ä¸€å¤©ã€‚", true);
        startNewDay();
        return;
      }
      // ç®±å­
      if (x === 0 && y === 1) {
        openChest();
        return;
      }
      // åœ°é“å…¥å£
      if (x === 1 && y === 2) {
        enterDungeon();
        return;
      }
      // å•†äºº
      if (gameState.base.merchant && x === 2 && y === 0) {
        openMerchant();
        return;
      }

      pushLog("è¿™é‡Œæ²¡æœ‰å¯ä»¥äº’åŠ¨çš„ä¸œè¥¿ã€‚");
    }
  }

  function handleDungeonKey(e) {
    const key = e.key;
    let dx = 0, dy = 0;
    if (key === "ArrowUp" || key === "w" || key === "W") dy = -1;
    else if (key === "ArrowDown" || key === "s" || key === "S") dy = 1;
    else if (key === "ArrowLeft" || key === "a" || key === "A") dx = -1;
    else if (key === "ArrowRight" || key === "d" || key === "D") dx = 1;

    if (dx !==0 || dy !==0) {
      mineOrMove(dx,dy);
      return;
    }

    if (key === " " || key === "Enter" || key === "e" || key === "E") {
      if (gameState.playerPos &&
          gameState.playerPos.x === gameState.dungeonSpawn.x &&
          gameState.playerPos.y === gameState.dungeonSpawn.y) {
        returnToBaseFromDungeon();
        return;
      } else {
        pushLog("åªæœ‰å›åˆ°å‡ºç”Ÿç‚¹æ‰èƒ½æ²¿ç€æ¢¯å­çˆ¬å›åŸºåœ°ã€‚");
      }
    }
  }

  // åˆå§‹åŒ–ä¼šåœ¨æ•…äº‹ç»“æŸå startNewRun()
</script>
</body>
</html>
